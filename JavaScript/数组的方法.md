内容来自MDN，迁移的过程也是学习的过程。

## 构造函数

### `Array()`: 创建一个新的 Array 对象。

!> 调用 `Array()` 时可以使用或不使用 new。两者都会创建一个新的 Array 实例。

- Array 构造函数会根据给定的元素创建一个 JavaScript 数组，但是当仅有一个参数且为数字时除外。注意，后者仅适用于用 Array 构造函数创建数组，而不适用于用方括号创建的数组字面量。

- 如果传递给 Array 构造函数的唯一参数是介于 0 到 232 - 1（含）之间的整数，这将返回一个新的 JavaScript 数组，其 length 属性设置为该数字（注意：这意味着一个由 arrayLength 个空槽组成的数组，而不是具有实际 undefined 值的槽——参见稀疏数组）。

```js
new Array()
new Array(1) // [empty] 创建一个长度为 1 的空数组
new Array('1') // ['1'] 创建一个长度为 1 的数组，且第一个元素为 '1'
new Array(1, 2) // [1, 2] 创建一个长度为 2 的数组，且第一个元素为 1，第二个元素为 2
new Array(1, 2, /* … ,*/ 999)
new Array(arrayLength) // 至输入一个数字会创建该数字长度的空数组，输入其他内容会以该内容创建数组

Array()
Array(1)
Array(1, 2)
Array(1, 2, /* … ,*/ 999)
Array(arrayLength)
```

## 静态方法

### `from(arrayLike, mapFn, thisArg)`: 从可迭代或类数组对象创建一个新的浅拷贝的数组实例。
- arrayLike 想要转换成数组的类数组或可迭代对象。
- mapFn 可选 调用数组每个元素的函数。如果提供，每个将要添加到数组中的值首先会传递给该函数，然后将 mapFn 的返回值增加到数组中。使用以下参数调用该函数：
  - element 数组当前正在处理的元素。
  - index 数组当前正在处理的元素的索引。
- thisArg 可选 执行 mapFn 时用作 this 的值。
- 返回值 一个新的数组实例。
- Array.from() 可以通过以下方式来创建数组对象：
  - 可迭代对象（例如 Map 和 Set 对象）；或者，如果对象是不可迭代的，
  - 类数组对象（带有 length 属性和索引元素的对象）。
- Array.from() 绝不会创建稀疏数组。如果 arrayLike 对象缺少一些索引属性，那么这些属性在新数组中将是 undefined。
- Array.from() 有一个可选的参数 mapFn，该参数允许你在创建数组时为每个元素执行一个函数，类似于 map()。更明确地说，Array.from(obj, mapFn, thisArg) 和 Array.from(obj).map(mapFn, thisArg) 具有相同的结果，只是它不会创建中间数组，并且 mapFn 仅接受两个参数（element、index），不接受数组，因为数组仍然在构建中。
- Array.from() 方法是一个通用的工厂方法。例如，如果一个数组类的子类继承 from() 方法，继承的 from() 方法将返回新的子类的实例，而不是数组的实例。事实上，this 值可以是任意的构造函数，只要该构造函数接受一个表示新数组长度的单个参数。当一个迭代器对象作为类数组传递时，不带参数调用构造函数；当传递类数组对象时，将携带类数组对象的规范化长度调用构造函数。迭代完成时，将再次设置最终的 length。如果 this 值并不是构造函数，则使用 Array 构造函数。
```js
Array.from("foo");
// [ "f", "o", "o" ]
const set = new Set(["foo", "bar", "baz", "foo"]);
Array.from(set);
// [ "foo", "bar", "baz" ]
const map = new Map([
  [1, 2],
  [2, 4],
  [4, 8],
]);
Array.from(map);
// [[1, 2], [2, 4], [4, 8]]
const mapper = new Map([
  ["1", "a"],
  ["2", "b"],
]);
Array.from(mapper.values());
// ['a', 'b'];
Array.from(mapper.keys());
// ['1', '2'];
function f() {
  return Array.from(arguments);
}
f(1, 2, 3);
// [ 1, 2, 3 ]
// 使用箭头函数作为映射函数去操作多个元素
Array.from([1, 2, 3], (x) => x + x);
// [2, 4, 6]
// 生成一个数字序列。因为数组在每个位置都使用 `undefined` 初始化，下面的 `v` 值将是 `undefined`
Array.from({ length: 5 }, (v, i) => i);
// [0, 1, 2, 3, 4]
// 序列生成器函数（通常称为“range”，例如 Clojure、PHP 等）
const range = (start, stop, step) =>
  Array.from({ length: (stop - start) / step + 1 }, (_, i) => start + i * step);
// 生成的数字范围 0..4
range(0, 4, 1);
// [0, 1, 2, 3, 4]
// 生成的数字范围 1..10，步长为 2
range(1, 10, 2);
// [1, 3, 5, 7, 9]
// 使用 Array.from 生成字母表，并将其序列排序
range("A".charCodeAt(0), "Z".charCodeAt(0), 1).map((x) =>
  String.fromCharCode(x),
);
// ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"]
```
   
### `fromAsync(arrayLike, mapFn, thisArg)`: 可以由一个异步可迭代对象、可迭代对象或类数组对象创建一个新的、浅拷贝的 Array 实例。
- arrayLike 要转换为数组的异步可迭代、可迭代或类数组对象。
- mapFn 可选 为数组中的每个元素执行的函数。如果提供了该函数，则每个要添加到数组中的值都会先通过该函数处理，mapFn 的返回值将代替该值被添加到数组中（在等待兑现后）。该函数被调用时将传入以下参数：
  - element 数组中当前正在处理的元素。由于所有元素都会先等待其兑现，因此该值永远不会是 thenable。
  - index 正在处理的元素在数组中的索引。
- thisArg 可选 执行 mapFn 时用作 this 的值。
- 返回值 一个新的 Promise，其兑现值是一个新的 Array 实例。
- Array.fromAsync() 允许你从以下对象中创建数组：
  - 异步可迭代对象（如 ReadableStream 和 AsyncGenerator）；或者，如果对象不是异步可迭代的，
  - 可迭代对象（如 Map 和 Set）；或者，如果对象是不可迭代的，
  - 类数组的对象（带有 length 属性和索引元素的对象）。
- Array.fromAsync() 迭代异步可迭代对象的方式与 for await...of 很相似。Array.fromAsync() 在行为上与 Array.from() 几乎等价，除了以下几点：
  - Array.fromAsync() 可以处理异步可迭代对象。
  - Array.fromAsync() 返回一个会兑现为数组实例的 Promise。
  - 如果使用非异步可迭代对象调用 Array.fromAsync()，则要添加到数组中的每个元素（无论是否为 Promise）都会先等待其兑现。
  - 如果提供了 mapFn，则其输入和输出会在内部等待兑现。
- Array.fromAsync() 和 Promise.all() 都可以将一个 promise 可迭代对象转换为一个数组的 promise。然而，它们有两个关键区别：
  - Array.fromAsync() 会依次等待对象中产生的每个值兑现。Promise.all() 会并行等待所有值兑现。
  - Array.fromAsync() 惰性迭代可迭代对象，并且不会获取下一个值，直到当前值被兑现。Promise.all() 预先获取所有值并等待它们全部兑现。
```js
const asyncIterable = (async function* () {
  for (let i = 0; i < 5; i++) {
    await new Promise((resolve) => setTimeout(resolve, 10 * i));
    yield i;
  }
})();
Array.fromAsync(asyncIterable).then((array) => console.log(array));
// [0, 1, 2, 3, 4]
```
```js
Array.fromAsync(
  new Map([
    [1, 2],
    [3, 4],
  ]),
).then((array) => console.log(array));
// [[1, 2], [3, 4]]
Array.fromAsync(
  new Set([Promise.resolve(1), Promise.resolve(2), Promise.resolve(3)]),
).then((array) => console.log(array));
// [1, 2, 3]
Array.fromAsync({
  length: 3,
  0: Promise.resolve(1),
  1: Promise.resolve(2),
  2: Promise.resolve(3),
}).then((array) => console.log(array));
// [1, 2, 3]
function delayedValue(v) {
  return new Promise((resolve) => setTimeout(() => resolve(v), 100));
}
Array.fromAsync(
  [delayedValue(1), delayedValue(2), delayedValue(3)],
  (element) => delayedValue(element * 2),
).then((array) => console.log(array));
// [2, 4, 6]
```
   
### `isArray(value)`: 用于确定传递的值是否是一个数组，如果参数是数组则返回 true ，否则返回 false。
- value 需要检测的值。
- 返回值 如果 value 是 Array，则为 true；否则为 false。如果 value 是 TypedArray 实例，则总是返回 false。
  - TypedArray 一个 TypedArray 对象描述了底层二进制数据缓冲区的类数组视图。没有称为 TypedArray 的全局属性，也没有直接可用的 TypedArray 构造函数。但是，有很多不同的全局属性，其值是指定元素类型的类型化数组构造函数。
- Array.isArray() 检查传递的值是否为 Array。它不检查值的原型链，也不依赖于它所附加的 Array 构造函数。对于使用数组字面量语法或 Array 构造函数创建的任何值，它都会返回 true。这使得它可以安全地使用跨领域（cross-realm）对象，其中 Array 构造函数的标识是不同的，因此会导致 instanceof Array 失败。
- Array.isArray() 也拒绝原型链中带有 Array.prototype，而实际不是数组的对象，但 instanceof Array 会接受。
- 当检测 Array 实例时，Array.isArray 优于 instanceof，因为 Array.isArray 能跨领域工作。
```js
// 下面的函数调用都返回 true
Array.isArray([]);
Array.isArray([1]);
Array.isArray(new Array());
Array.isArray(new Array("a", "b", "c", "d"));
Array.isArray(new Array(3));
// 鲜为人知的事实：其实 Array.prototype 也是一个数组：
Array.isArray(Array.prototype);
//
// 下面的函数调用都返回 false
Array.isArray();
Array.isArray({});
Array.isArray(null);
Array.isArray(undefined);
Array.isArray(17);
Array.isArray("Array");
Array.isArray(true);
Array.isArray(false);
Array.isArray(new Uint8Array(32));
// 这不是一个数组，因为它不是使用数组字面量语法或 Array 构造函数创建的
Array.isArray({ __proto__: Array.prototype });
```
```js
// instanceof 和 Array.isArray()
// 当检测 Array 实例时，Array.isArray 优于 instanceof，因为 Array.isArray 能跨领域工作。
const iframe = document.createElement("iframe");
document.body.appendChild(iframe);
const xArray = window.frames[window.frames.length - 1].Array;
const arr = new xArray(1, 2, 3); // [1, 2, 3]
// 正确检查 Array
Array.isArray(arr); // true
// arr 的原型是 xArray.prototype，它是一个不同于 Array.prototype 的对象
arr instanceof Array; // false
```

### `of(element0, element1, /* … ,*/ elementN)`: 通过可变数量的参数创建一个新的 Array 实例，而不考虑参数的数量或类型。
- elementN 用于创建数组的元素。
- 返回值 新的 Array 实例。
- Array.of() 和 Array() 构造函数之间的区别在于对单个参数的处理：Array.of(7) 创建一个具有单个元素 7 的数组，而 Array(7) 创建一个 length 为 7 的空数组（这意味着一个由 7 个空槽组成的数组，而不是由 7 个 undefined 组成的数组）。
- Array.of() 方法是一个通用的工厂方法。例如，如果 Array 的子类继承了 of() 方法，继承的 of() 方法将返回子类的新实例而不是 Array 实例。事实上，this 值可以是任何接受单个参数表示新数组长度的构造函数，并且构造函数将与传递给 of() 的参数数量一起被调用。当所有元素都被分配时，最终的 length 将再次设置。如果 this 值不是构造函数，则改用普通的 Array 构造函数。
```js
Array.of(7); // [7]
Array(7); // 由 7 个空槽组成的数组
Array.of(1, 2, 3); // [1, 2, 3]
Array(1, 2, 3); // [1, 2, 3]
Array.of(undefined); // [undefined]
```
```js
function NotArray(len) {
  console.log("NotArray called with length", len);
}
console.log(Array.of.call(NotArray, 1, 2, 3));
// NotArray called with length 3
// NotArray { '0': 1, '1': 2, '2': 3, length: 3 }
console.log(Array.of.call(Object)); // [Number: 0] { length: 0 }
```
```js
console.log(Array.of.call({}, 1)); // [ 1 ]
```


## 实例属性

- 以下属性在 Array.prototype 上定义，并由所有 Array 实例共享。
   
   1. `Array.prototype.constructor`: 创建实例对象的构造函数。对于 Array 实例，初始值是 Array 构造函数。
   
   2. `Array.prototype[@@unscopables]`: Array.prototype 的 @@unscopables 数据属性被所有 Array 实例共享。它包含在 ES2015 版本之前 ECMAScript 标准中未收纳的属性名，并且这些属性被排除在由 with 语句绑定的环境中。
   
- 以下属性是每个 Array 实例自有的属性。
   
   1. `Array.prototype.length`: length 是 Array 的实例属性，表示该数组中元素的个数。该值是一个无符号 32 位整数，并且其数值总是大于数组最大索引。


## 实例方法

### `at(index)`: 接收一个整数值并返回该索引对应的元素，允许正数和负数。负整数从数组中的最后一个元素开始倒数。如果 `index < -array.length` 或 `index >= array.length`，则总是返回 `undefined`，而不会尝试访问相应的属性。
- index 要返回的数组元素的索引（从零开始），会被转换为整数。负数索引从数组末尾开始计数——如果 index < 0，则会访问 index + array.length 位置的元素。
- 返回数组中与给定索引匹配的元素。如果 index < -array.length 或 index >= array.length，则总是返回 undefined，而不会尝试访问相应的属性。
- 在传递非负数时，at() 方法等价于括号表示法。例如，array[0] 和 array.at(0) 均返回第一个元素。但是，当你需要从数组的末端开始倒数时，则不能使用 Python 和 R 语言中支持的 array[-1]，因为方括号内的所有值都会被视为字符串属性，因此你最终读取的是 array["-1"]，这只是一个普通的字符串属性而不是数组索引。
- 通常的做法是访问 length 并将其减去从末端开始的相对索引。例如，array[array.length - 1]。at() 方法允许使用相对索引，因此上面的示例可以简化为 array.at(-1)。
- at() 方法是通用的。其仅期望 this 具有 length 属性和以整数为键的属性。

```js
const array1 = [5, 12, 8, 130, 44];
let index = 2;
console.log(`An index of ${index} returns ${array1.at(index)}`);
// Expected output: "An index of 2 returns 8"
index = -2;
console.log(`An index of ${index} returns ${array1.at(index)}`);
// Expected output: "An index of -2 returns 130"
```

### `concat(value0, value1, /* … ,*/ valueN)`: 用于合并两个或多个数组。此方法**不会更改现有数组**，而是返回一个新数组。
- valueN 可选 数组和/或值，将被合并到一个新的数组中。如果省略了所有 valueN 参数，则 concat 会返回调用此方法的现存数组的一个浅拷贝。
- 返回值 新的 Array 实例。
- concat 方法创建一个新数组。该数组将首先由调用它的对象中的元素填充。然后，对于每个参数，它的值将被连接到数组中——对于普通对象或基元，参数本身将成为最终数组的一个元素；对于属性Symbol.isConcatSpreadable设置为真的数组或类数组对象，参数的每个元素都将是独立地添加到最终数组中。concat 方法不会递归到嵌套数组参数中。
- 如果任何源数组是稀疏数组，concat() 方法会保留空槽。
- concat() 方法是一种复制方法。它不会更改 this 或作为参数提供的任何数组，而是返回包含与原始数组中的元素相同的元素的浅拷贝。
- 如果任何源数组是稀疏数组，concat() 方法会保留空槽。
- concat() 方法是通用的。this 值的处理方式与其他参数相同（除了它会先转换为对象），这意味着普通对象将直接添加到结果数组中，而 @@isConcatSpreadable 属性为真值的类数组对象将展开并添加到数组中。

```js
const array1 = ['a', 'b', 'c'];
const array2 = ['d', 'e', 'f'];
const array3 = array1.concat(array2);
console.log(array3);
// Expected output: Array ["a", "b", "c", "d", "e", "f"]
```

### `copyWithin(target, start, end)`: 浅复制数组的一部分到同一数组中的另一个位置并替换另一位置的元素值，并返回它，不会改变原数组的长度，但**会改变原数组**。
- target 序列开始替换的目标位置，以 0 为起始的下标表示，且将被转换为整数
  - 负索引将从数组末尾开始计数——如果 target < 0，则实际是 target + array.length。
  - 如果 target < -array.length，则使用 0。
  - 如果 target >= array.length，则不会拷贝任何内容。
  - 如果 target 位于 start 之后，则复制只会持续到 array.length 结束（换句话说，copyWithin() 永远不会扩展数组）。
- start 可选 要复制的元素序列的起始位置，以 0 为起始的下标表示，且将被转换为整数
  - 负索引将从数组末尾开始计数——如果 start < 0，则实际是 start + array.length。
  - 如果省略 start 或 start < -array.length，则默认为 0。
  - 如果 start >= array.length，则不会拷贝任何内容。
- end 可选 要复制的元素序列的结束位置，以 0 为起始的下标表示，且将被转换为整数。copyWithin 将会拷贝到该位置，但不包括 end 这个位置的元素。
  - 负索引将从数组末尾开始计数——如果 end < 0，则实际是 end + array.length。
  - 如果 end < -array.length，则使用0。
  - 如果省略 end 或 end >= array.length，则默认为 array.length，这将导致直到数组末尾的所有元素都被复制。
  - 如果 end 位于 start 之前，则不会拷贝任何内容。
- 返回值 改变后的数组。
- copyWithin() 方法的工作原理类似于 C 和 C++ 的 memmove，是一种移动数组数据的高性能方法，与 TypedArray 的同名方法类似。序列在一次中操作被复制和粘贴；即使复制和粘贴区域重叠，粘贴的序列也将具有复制值。
- copyWithin() 是修改方法。它不会改变 this 指向的对象（数组或类数组）的长度，但会更改其的内容，并在必要时创建新属性或删除现有属性。
- copyWithin() 方法保留空槽。如果要复制的区域是稀疏的，则原来的空槽会被删除并被替换为拷贝的空槽。
- copyWithin() 方法是通用的。它只期望 this 值具有 length 属性和整数键属性。虽然字符串也是类似数组的，但这种方法不适用于它们，因为字符串是不可变的。

```js
console.log([1, 2, 3, 4, 5].copyWithin(-2));
// [1, 2, 3, 1, 2]
console.log([1, 2, 3, 4, 5].copyWithin(0, 3));
// [4, 5, 3, 4, 5]
console.log([1, 2, 3, 4, 5].copyWithin(0, 3, 4));
// [4, 2, 3, 4, 5]
console.log([1, 2, 3, 4, 5].copyWithin(-2, -3, -1));
// [1, 2, 3, 3, 4]
console.log([1, , 3].copyWithin(2, 1, 2)); // [1, empty, empty]
```

### `entries()`: 返回一个新的数组迭代器对象，该对象包含数组中每个索引的键/值对。
- 返回值 一个新的可迭代迭代器对象 (en-US)。
- 当在稀疏数组上使用时，entries() 方法迭代空槽，就像它们的值为 undefined 一样。
- entries() 方法是通用的。它只要求 this 值具有 length 属性和以整数为键的属性。

```js
const array1 = ['a', 'b', 'c'];
const iterator1 = array1.entries();
console.log(iterator1.next().value);
// Expected output: Array [0, "a"]
console.log(iterator1.next().value);
// Expected output: Array [1, "b"]
const a = ["a", "b", "c"];
for (const [index, element] of a.entries()) {
    console.log(index, element);
}
// 0 'a'
// 1 'b'
// 2 'c'
for (const element of [, "a"].entries()) {
    console.log(element);
}
// [0, undefined]
// [1, 'a']
```

### `every(callbackFn, thisArg)`: 测试一个数组内的所有元素是否都能通过指定函数的测试。它返回一个布尔值。
- callbackFn 为数组中的每个元素执行的函数。它应该返回一个真值以指示元素通过测试，否则返回一个假值。该函数被调用时将传入以下参数：
  - element 数组中当前正在处理的元素。
  - index 正在处理的元素在数组中的索引。
  - array 调用了 every() 的数组本身。
- thisArg 可选 执行 callbackFn 时用作 this 的值。
- 返回值 如果 callbackFn 为每个数组元素返回真值，则为 true。否则为 false。
- every() 方法是一个迭代方法。它为数组中的每个元素调用一次指定的 callbackFn 函数，直到 callbackFn 返回一个假值。如果找到这样的元素，every() 方法将会立即返回 false 并停止遍历数组。否则，如果 callbackFn 为每个元素返回一个真值，every() 就会返回 true。
- every 和数学中的全称量词"任意（∀）"类似。特别的，对于空数组，它只返回 true。（这种情况属于无条件正确，因为空集的所有元素都符合给定的条件。）
- callbackFn 仅针对已分配值的数组索引调用。它不会为稀疏数组中的空槽调用。
- every() 不会改变调用它的数组，但指定的 callbackFn 函数可以。但是请注意，数组的长度是在第一次调用 callbackFn 之前保存的。
  - 当开始调用 every() 时，callbackFn 将不会访问超出数组初始长度的任何元素。
  - 对已访问索引的更改不会导致再次在这些元素上调用 callbackFn。
  - 如果数组中一个现有的、尚未访问的元素被 callbackFn 更改，则它传递给 callbackFn 的值将是该元素被修改后的值。被删除的元素则不会被访问。
- every() 方法是通用的。它只期望 this 值具有 length 属性和整数键属性。

```js
const isBelowThreshold = (currentValue) => currentValue < 40;
const array1 = [1, 30, 39, 29, 10, 13];
console.log(array1.every(isBelowThreshold));
// Expected output: true
const isSubset = (array1, array2) =>
  array2.every((element) => array1.includes(element));
console.log(isSubset([1, 2, 3, 4, 5, 6, 7], [5, 7, 6])); // true
console.log(isSubset([1, 2, 3, 4, 5, 6, 7], [5, 8, 7])); // false
console.log([1, , 3].every((x) => x !== undefined)); // true
console.log([2, , 2].every((x) => x === 2)); // true
```
```js
// --------------
//   修 改 元 素
// --------------
let arr = [1, 2, 3, 4];
arr.every((elem, index, arr) => {
  arr[index + 1]--;
  console.log(`[${arr}][${index}] -> ${elem}`);
  return elem < 2;
});
// 循环会迭代 3 次
// 没有修改的情况下只会迭代 2 次
//
// 第 1 次迭代：[1,1,3,4][0] -> 1
// 第 2 次迭代：[1,1,2,4][1] -> 1
// 第 3 次迭代：[1,1,2,3][2] -> 2
//
// --------------
//   添 加 元 素
// --------------
arr = [1, 2, 3];
arr.every((elem, index, arr) => {
  arr.push("new");
  console.log(`[${arr}][${index}] -> ${elem}`);
  return elem < 4;
});
// 循环迭代 3 次，即使在添加新元素之后
//
// 第 1 次迭代：[1, 2, 3, new][0] -> 1
// 第 2 次迭代：[1, 2, 3, new, new][1] -> 2
// 第 3 次迭代：[1, 2, 3, new, new, new][2] -> 3
//
// --------------
//   删 除 元 素
// --------------
arr = [1, 2, 3, 4];
arr.every((elem, index, arr) => {
  arr.pop();
  console.log(`[${arr}][${index}] -> ${elem}`);
  return elem < 4;
});
// 循环仅迭代 2 次
// 因为剩余的元素被 `pop()` 删除
//
// 第 1 次迭代：[1,2,3][0] -> 1
// 第 2 次迭代：[1,2][1] -> 2
```

### `fill(value, start, end)`: 用一个固定值填充一个数组中从起始索引（默认为 0）到终止索引（默认为 array.length）内的全部元素。它返回修改后的数组。
- value 用来填充数组元素的值。注意所有数组中的元素都将是这个确定的值：如果 value 是个对象，那么数组的每一项都会引用这个元素。
- start 可选 基于零的索引，从此开始填充，转换为整数。
  - 负数索引从数组的末端开始计算，如果 start < 0，则使用 start + array.length。
  - 如果 start < -array.length 或 start 被省略，则使用 0。
  - 如果 start >= array.length，没有索引被填充。
- end 可选 基于零的索引，在此结束填充，转换为整数。fill() 填充到但不包含 end 索引。
  - 负数索引从数组的末端开始计算，如果 end < 0，则使用 end + array.length。
  - 如果 end < -array.length，则使用 0。
  - 如果 end >= array.length 或 end 被省略，则使用 array.length，导致所有索引都被填充。
  - 如果经标准化后，end 的位置在 start 之前或之上，没有索引被填充。
- 返回值 经 value 填充修改后的数组。
- fill() 是个修改方法，不会改变 this 的长度，但会改变 this 的内容。
- fill() 也会使用 value 填充稀疏数组的空槽。
- fill() 方法是通用的。它只期望 this 值有一个 length 属性。虽然字符串也是类似数组的，但这个方法不适合应用于它们，因为字符串是不可变的。
- 在一个空数组（length = 0）上使用 Array.prototype.fill() 不会对其进行修改，因为数组没有要修改的内容。要在声明一个数组时使用 Array.prototype.fill()，请确保数组的 length 不为零。
```js
console.log([1, 2, 3].fill(4)); // [4, 4, 4]
console.log([1, 2, 3].fill(4, 1)); // [1, 4, 4]
console.log([1, 2, 3].fill(4, 1, 2)); // [1, 4, 3]
console.log([1, 2, 3].fill(4, 1, 1)); // [1, 2, 3]
console.log([1, 2, 3].fill(4, 3, 3)); // [1, 2, 3]
console.log([1, 2, 3].fill(4, -3, -2)); // [4, 2, 3]
console.log([1, 2, 3].fill(4, NaN, NaN)); // [1, 2, 3]
console.log([1, 2, 3].fill(4, 3, 5)); // [1, 2, 3]
console.log(Array(3).fill(4)); // [4, 4, 4]
// 一个简单的对象，被数组的每个空槽所引用
const arr = Array(3).fill({}); // [{}, {}, {}]
arr[0].hi = "hi"; // [{ hi: "hi" }, { hi: "hi" }, { hi: "hi" }]
const tempGirls = Array(5).fill("girl", 0); // 将所有值设定为一个特定的值。无需指定 end 参数。 注意，数组最初为稀疏数组，没有分配索引。fill() 仍然可以填充这个数组。
console.log(tempGirls); // ["girl", "girl", "girl", "girl", "girl"]
const arrayLike = { length: 2 };
console.log(Array.prototype.fill.call(arrayLike, 1));
// { '0': 1, '1': 1, length: 2 }
```

### `filter(callbackFn, thisArg)`: 返回一个新数组，其中包含调用所提供的筛选函数返回为 true 的所有数组元素。
- callbackFn  为数组中的每个元素执行的函数。它应该返回一个真值以将元素保留在结果数组中，否则返回一个假值。该函数被调用时将传入以下参数：
  - element 数组中当前正在处理的元素。
  - index 正在处理的元素在数组中的索引。
  - array 调用了 filter() 的数组本身。
- thisArg 可选 执行 callbackFn 时用作 this 的值。参见迭代方法。
- 返回值 返回给定数组的一部分的浅拷贝，其中只包括通过提供的函数实现的测试的元素。如果没有元素通过测试，则返回一个空数组。
- filter() 方法是一个迭代方法。它为数组中的每个元素调用提供的 callbackFn 函数一次，并构造一个由所有返回真值的元素值组成的新数组。未通过 callbackFn 测试的数组元素不会包含在新数组中。
- callbackFn 仅对已分配值的数组索引调用。它不会对稀疏数组中的空槽调用。
- filter() 方法是一个复制方法。它不会改变 this，而是返回一个包含与原始数组相同的元素（其中某些元素已被过滤掉）的浅拷贝。但是，作为 callbackFn 的函数可以更改数组。请注意，在第一次调用 callbackFn 之前，数组的长度已经被保存。因此：
  - 当开始调用 filter() 时，callbackFn 将不会访问超出数组初始长度的任何元素。
  - 对已访问索引的更改不会导致再次在这些元素上调用 callbackFn。
  - 如果数组中一个现有的、尚未访问的元素被 callbackFn 更改，则它传递给 callbackFn 的值将是该元素被修改后的值。被删除的元素则不会被访问。
- filter() 方法是通用的。它只期望 this 值具有 length 属性和整数键属性。
```js
const array = [-3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13];
function isPrime(num) {
  for (let i = 2; num > i; i++) {
    if (num % i === 0) {
      return false;
    }
  }
  return num > 1;
}
console.log(array.filter(isPrime)); // [2, 3, 5, 7, 11, 13]
const fruits = ["apple", "banana", "grapes", "mango", "orange"];
/**
 * 根据搜索条件（查询）筛选数组项
 */
function filterItems(arr, query) {
  return arr.filter((el) => el.toLowerCase().includes(query.toLowerCase()));
}
console.log(filterItems(fruits, "ap")); // ['apple', 'grapes']
console.log(filterItems(fruits, "an")); // ['banana', 'mango', 'orange']
console.log([1, , undefined].filter((x) => x === undefined)); // [undefined]
console.log([1, , undefined].filter((x) => x !== 2)); // [1, undefined]
const arrayLike = {
  length: 3,
  0: "a",
  1: "b",
  2: "c",
};
console.log(Array.prototype.filter.call(arrayLike, (x) => x <= "b"));
// [ 'a', 'b' ]
```
```js
// 修改每个单词
let words = ["spray", "limit", "exuberant", "destruction", "elite", "present"];
//
const modifiedWords = words.filter((word, index, arr) => {
  arr[index + 1] += " extra";
  return word.length < 6;
});
//
console.log(modifiedWords);
// 注意，在长度为 6 以下有三个单词，但是由于它们已经被修改，所以返回一个单词
// ["spray"]
//
// 添加新单词
words = ["spray", "limit", "exuberant", "destruction", "elite", "present"];
const appendedWords = words.filter((word, index, arr) => {
  arr.push("new");
  return word.length < 6;
});
//
console.log(appendedWords);
// 只有三个符合条件，即使 `words` 本身现在有更多字符长度小于 6 的单词
// ["spray" ,"limit" ,"elite"]
//
// 删除单词
words = ["spray", "limit", "exuberant", "destruction", "elite", "present"];
const deleteWords = words.filter((word, index, arr) => {
  arr.pop();
  return word.length < 6;
});
//
console.log(deleteWords);
// 注意我们没有得到 'elite'，因为它在过滤器访问到它之前就已经从 'words' 弹出了
// ["spray" ,"limit"]
```

### `find(callbackFn, thisArg)`: 返回数组中满足提供的测试函数的第一个元素的值，如果没有找到合适的元素，则返回 undefined。
- callbackFn 为数组中的每个元素执行的函数。它应该返回一个真值来表示已经找到了匹配的元素。该函数被调用时将传入以下参数：
  - element 数组中当前正在处理的元素。
  - index 正在处理的元素在数组中的索引。
  - array 调用了 find() 的数组本身。
- thisArg 可选 执行 callbackFn 时用作 this 的值。
- 返回值 数组中第一个满足所提供测试函数的元素的值，否则返回 undefined。
- find() 方法是一个迭代方法。它按索引升序顺序为数组中的每个元素调用提供的 callbackFn 函数，直到 callbackFn 返回一个真值。然后 find() 返回该元素并停止迭代数组。如果 callbackFn 从未返回真值，则 find() 返回 undefined。
- callbackFn 被调用来处理数组的每一个索引，而不仅仅是那些有值的索引。在稀疏数组中，未赋值的空槽与 undefined 表现相同。
- find() 不会改变被调用的数组，但是提供给 callbackFn 的函数可能会改变它。但需要注意的是，在第一次调用 callbackFn 之前，数组的长度会被保存。因此：
  - 当调用 find() 时，callbackFn 不会访问超出数组初始长度的任何元素
  - 对已经访问过的索引的更改不会导致再次在这些元素上调用 callbackFn。
  - 如果 callbackFn 改变了数组中已存在但尚未被访问的元素，则传递给 callbackFn 的该元素的值将是该元素在被访问时的值。被删除的元素被视为 undefined。
- find() 方法是通用的。它只期望 this 值具有 length 属性和整数键属性。
```js
const inventory = [
  { name: "apples", quantity: 2 },
  { name: "bananas", quantity: 0 },
  { name: "cherries", quantity: 5 },
];
const result = inventory.find(({ name }) => name === "cherries");
console.log(result); // { name: 'cherries', quantity: 5 }
const arrayLike = {
  length: 3,
  0: 2,
  1: 7.3,
  2: 4,
};
console.log(Array.prototype.find.call(arrayLike, (x) => !Number.isInteger(x)));
// 7.3
const inventory = [
  { name: "apples", quantity: 2 },
  { name: "bananas", quantity: 0 },
  { name: "cherries", quantity: 5 },
];
const result = inventory.find(({ name }) => name === "cherries");
console.log(result); // { name: 'cherries', quantity: 5 }
const arrayLike = {
  length: 3,
  0: 2,
  1: 7.3,
  2: 4,
};
console.log(Array.prototype.find.call(arrayLike, (x) => !Number.isInteger(x)));
// 7.3
```
```js
// 声明一个在索引 2、3 和 4 处没有元素的数组
const array = [0, 1, , , , 5, 6];
//
// 将会打印所有索引，而不仅仅是那些有值的非空槽
array.find((value, index) => {
  console.log(`访问索引 ${index}，值为 ${value}`);
});
// 访问索引 0，值为 0
// 访问索引 1，值为 1
// 访问索引 2，值为 undefined
// 访问索引 3，值为 undefined
// 访问索引 4，值为 undefined
// 访问索引 5，值为 5
// 访问索引 6，值为 6
//
// 打印所有索引，包括已删除的
array.find((value, index) => {
  // 在第一次迭代时删除元素 5
  if (index === 0) {
    console.log(`删除 array[5] 的值 ${array[5]}`);
    delete array[5];
  }
  // 即使删除了，元素 5 仍然被访问
  console.log(`访问索引 ${index}，值为 ${value}`);
});
// 删除值为 5 的 array[5]
// 访问索引 0，值为 0
// 访问索引 1，值为 1
// 访问索引 2，值为 undefined
// 访问索引 3，值为 undefined
// 访问索引 4，值为 undefined
// 访问索引 5，值为 undefined
// 访问索引 6，值为 6\
```

### `findIndex(callbackFn, thisArg)`: 返回数组中满足提供的测试函数的第一个元素的索引，如果没有找到合适的元素，则返回 -1。
- callbackFn 为数组中的每个元素执行的函数。它应该返回一个真值以指示已找到匹配元素，否则返回一个假值。该函数被调用时将传入以下参数：
  - element 数组中当前正在处理的元素。
  - index 正在处理的元素在数组中的索引。
  - array 调用了 findIndex() 的数组本身。
- thisArg 可选 执行 callbackFn 时用作 this 的值。
- 返回值 数组中第一个满足测试条件的元素的索引。否则返回 -1。
- findIndex() 是一种迭代方法。它按照索引升序依次遍历数组中的每个元素，并调用提供的 callbackFn 函数，直到 callbackFn 返回一个真值。然后 findIndex() 返回该元素的索引并停止遍历数组。如果 callbackFn 从未返回一个真值，则 findIndex() 返回 -1。
- callbackFn 被调用来处理数组的每一个索引，而不仅仅是那些有值的索引。在稀疏数组中，未赋值的空槽与 undefined 表现相同。
- findIndex() 不会改变被调用的数组，但是提供给 callbackFn 的函数可能会改变它。但需要注意的是，在第一次调用 callbackFn 之前，数组的长度会被保存。因此：
  - 当调用 findIndex() 时，callbackFn 不会访问超出数组初始长度的任何元素。
  - 对已经访问过的索引的更改不会导致再次在这些元素上调用 callbackFn。
  - 如果 callbackFn 改变了数组中已存在但尚未被访问的元素，则传递给 callbackFn 的该元素的值将是该元素在被访问时的值。被删除的元素被视为 undefined。
- findIndex() 方法是通用的。它只期望 this 值具有 length 属性和整数键属性。
```js
console.log([5, 12, 8, 130, 44].findIndex((element) => element > 13)); // 3
console.log([1, , 3].findIndex((x) => x === undefined)); // 1
const arrayLike = {
  length: 3,
  0: 2,
  1: 7.3,
  2: 4,
};
console.log(
  Array.prototype.findIndex.call(arrayLike, (x) => !Number.isInteger(x)),
); // 1
const arrayLike = {
  length: 3,
  0: 2,
  1: 7.3,
  2: 4,
};
console.log(
  Array.prototype.findIndex.call(arrayLike, (x) => !Number.isInteger(x)),
); // 1
```

### `findLast(callbackFn, thisArg)`: 返回数组中满足提供的测试函数的最后一个元素的值，如果没有找到合适的元素，则返回 undefined。
- callbackFn 数组中测试元素的函数。回调应该返回一个真值，表示已找到匹配的元素，否则返回一个假值。函数在被调用时会传递以下参数：
  - element 当前遍历到的元素。
  - index 当前遍历到的元素的索引（位置）。
  - array 调用 findLast() 的数组本身。
- thisArg 可选 执行 callbackFn 时，用作 this 的值。
- 返回值 数组中满足提供的测试函数索引最高的元素；如果没有元素匹配，返回 undefined。
- findLast() 是一个迭代方法。该方法对数组每一个元素按降序（索引从大到小）执行 callbackFn 函数，直到 callbackFn 返回一个真值。然后 findLast() 返回该元素的值并停止遍历数组。如果 callbackFn 没有返回一个真值，则 findLast() 返回 undefined。
- callbackFn 会被数组中的每个元素调用，而不仅仅是那些被赋值的元素。对于稀疏数组来说，空槽行为和 undefined 相同。
- findLast() 方法不会改变调用它的数组，但是提供的 callbackFn 可以。但是请注意，数组的长度是在第一次调用 callbackFn 之前保存的。因此：
  - callbackFn 不会访问在调用 findLast() 开始后才添加到数组中的任何元素。
  - 给已访问过的索引重新赋值将不会被 callbackFn 重新访问。
  - 如果 callbackFn 更改了数组中现有的、尚未访问的元素，则其传递给 callbackFn 的值将是 findLast() 访问该元素索引时的值。已删除的元素会被当做 undefined 来访问。
- findLast() 方法是通用的。它只期望 this 值具有 length 属性和整数键的属性。
```js
const inventory = [
  { name: "apples", quantity: 2 },
  { name: "bananas", quantity: 0 },
  { name: "fish", quantity: 1 },
  { name: "cherries", quantity: 5 },
];
const result = inventory.findLast(({ quantity }) => quantity < 2);
console.log(result);
// { name: "fish", quantity: 1 }
const arrayLike = {
  length: 3,
  0: 2,
  1: 7.3,
  2: 4,
};
console.log(
  Array.prototype.findLast.call(arrayLike, (x) => Number.isInteger(x)),
); // 4
```
```js
// 声明一个在索引 2、3 和 4 处没有元素的数组
const array = [0, 1, , , , 5, 6];
//
// 显示所有的索引（不只包括那些被赋值的）
array.findLast((value, index) => {
  console.log(`访问索引 ${index}，值为 ${value}`);
});
// 访问索引 6，值为 6
// 访问索引 5，值为 5
// 访问索引 4，值为 undefined
// 访问索引 3，值为 undefined
// 访问索引 2，值为 undefined
// 访问索引 1，值为 1
// 访问索引 0，值为 0
//
// 显示所有的索引（包括已被删除的）
array.findLast((value, index) => {
  // 在第一次迭代时删除值为 5 的元素
  if (index === 6) {
    console.log(`删除值为 array[5]，其值为 ${array[5]}`);
    delete array[5];
  }
  // 元素 5 在被删除后，仍会被访问
  console.log(`访问索引 ${index}，值为 ${value}`);
});
// 删除值为 array[5]，其值为 5
// 访问索引 6，值为 6
// 访问索引 5，值为 undefined
// 访问索引 4，值为 undefined
// 访问索引 3，值为 undefined
// 访问索引 2，值为 undefined
// 访问索引 1，值为 1
// 访问索引 0，值为 0
```

### `findLastIndex(callbackFn, thisArg)`: 返回数组中满足所提供测试函数的最后一个元素的索引，如果没有找到合适的元素，则返回 -1。
- callbackFn 对数组中的每个元素执行的函数。回调必须返回一个真值，表示已找到匹配的元素，否则返回一个假值。函数在被调用时会传递以下参数：
  - element 当前遍历到的元素。
  - index 当前正在处理的元素的索引。
  - array 调用 findLastIndex() 的数组本身。
- thisArg 可选 执行 callbackFn 时，用作 this 的值。
- 返回值 数组中通过测试的最后一个（索引最大）元素的索引。如果没有找到任何匹配的元素，则返回 -1。
- findLastIndex() 方法是一个迭代方法。它为数组中的每个元素按索引降序调用一次提供的 callbackFn 函数，直到 callbackFn 返回一个真值。然后 findLastIndex() 返回元素的索引并且停止遍历数组。如果 callbackFn 没有返回一个真值，则 findLastIndex() 返回 -1。
- callbackFn 会为数组中的每个元素调用，而不仅仅是那些被赋值的元素，这意味着对于稀疏数组来说，空槽的行为和 undefined 相同。
- findLastIndex() 方法不会改变调用它的数组，但是提供的 callbackFn 可以。但是请注意，数组的长度是在第一次调用 callbackFn 之前保存的。因此：
  - callbackFn 不会访问在调用 findLastIndex() 开始后才添加到数组中的任何元素。
  - 对已访问索引的更改不会导致对它们再次调用 callbackFn 函数。
  - 如果 callbackFn 更改了数组中现有的、尚未访问的元素，它传递给callbackFn 的值将是该元素被访问时的值。已删除元素被当作 undefined 来访问。
- findLastIndex() 方法是通用的。它只期望 this 值具有 length 属性和整型键属性。
```js
function isPrime(element) {
  if (element % 2 === 0 || element < 2) {
    return false;
  }
  for (let factor = 3; factor <= Math.sqrt(element); factor += 2) {
    if (element % factor === 0) {
      return false;
    }
  }
  return true;
}
console.log([4, 6, 8, 12].findLastIndex(isPrime)); // -1，没有找到
console.log([4, 5, 7, 8, 9, 11, 12].findLastIndex(isPrime)); // 5
console.log([1, , 3].findLastIndex((x) => x === undefined)); // 1
const arrayLike = {
  length: 3,
  0: 2,
  1: 7.3,
  2: 4,
};
console.log(
  Array.prototype.findLastIndex.call(arrayLike, (x) => Number.isInteger(x)),
); // 2
```

### `flat(depth)`: 创建一个新的数组，并根据指定深度递归地将所有子数组元素拼接到新的数组中。
- depth 可选 指定要提取嵌套数组的结构深度，默认值为 1。
- 返回值 一个新的数组，其中包含拼接后的子数组元素。
- flat() 方法属于复制方法。它不会改变 this 数组，而是返回一个浅拷贝，该浅拷贝包含了原始数组中相同的元素。
- 如果待展开的数组是稀疏的，flat() 方法会忽略其中的空槽。例如，如果 depth 是 1，那么根数组和第一层嵌套数组中的空槽都会被忽略，但在更深的嵌套数组中的空槽则会与这些数组一起保留。
- flat() 方法是通用的。它只需要 this 值具有 length 属性和整数键属性即可。但是，如果要展开元素，则它们必须是数组。
```js
const arr1 = [1, 2, [3, 4]];
arr1.flat();
// [1, 2, 3, 4]
const arr2 = [1, 2, [3, 4, [5, 6]]];
arr2.flat();
// [1, 2, 3, 4, [5, 6]]
const arr3 = [1, 2, [3, 4, [5, 6]]];
arr3.flat(2);
// [1, 2, 3, 4, 5, 6]
const arr4 = [1, 2, [3, 4, [5, 6, [7, 8, [9, 10]]]]];
arr4.flat(Infinity);
// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
const arr5 = [1, 2, , 4, 5];
console.log(arr5.flat()); // [1, 2, 4, 5]
const array = [1, , 3, ["a", , "c"]];
console.log(array.flat()); // [ 1, 3, "a", "c" ]
const array2 = [1, , 3, ["a", , ["d", , "e"]]];
console.log(array2.flat()); // [ 1, 3, "a", ["d", empty, "e"] ]
console.log(array2.flat(2)); // [ 1, 3, "a", "d", "e"]
const arrayLike = {
  length: 3,
  0: [1, 2],
  // 嵌套的类数组对象不会被展平
  1: { length: 2, 0: 3, 1: 4 },
  2: 5,
};
console.log(Array.prototype.flat.call(arrayLike));
// [ 1, 2, { '0': 3, '1': 4, length: 2 }, 5 ]
```

### `flatMap(callbackFn, thisArg)`: 对数组中的每个元素应用给定的回调函数，然后将结果展开一级，返回一个新数组。它等价于在调用 map() 方法后再调用深度为 1 的 flat() 方法（arr.map(...args).flat()），但比分别调用这两个方法稍微更高效一些。
- callbackFn 一个在数组的每个元素上执行的函数。它应该返回一个包含新数组元素的数组，或是要添加到新数组中的单个非数组值。该函数将被传入以下参数：
  - element 数组中正在处理的当前元素。
  - index 数组中正在处理的当前元素的索引。
  - array 调用 flatMap() 的当前数组。
- thisArg 可选 在执行 callbackFn 时用作 this 的值。
- 返回值 一个新的数组，其中每个元素都是回调函数的结果，并且被展开一级。
- flatMap() 方法是一个迭代方法。有关回调函数的详细说明，请参见 Array.prototype.map()。flatMap() 方法等同于调用 map(callbackFn, thisArg) 后再调用 flat(1)——对于每个元素，它都会生成一个新元素数组，并将生成的数组连接起来形成一个新数组。
- flatMap() 方法是通用的。它只需要 this 值具有 length 属性和整数键属性即可。但是，如果要展开从回调函数 callbackFn 返回的值，则该值必须是数组。
- callbackFn 不会被源数组中的空槽调用，因为 map() 不会调用，而 flat() 将忽略返回数组中的空槽。
```js
const arr = [1, 2, 3, 4];
arr.flatMap((x) => [x, x * 2]);
// 等价于
const n = arr.length;
const acc = new Array(n * 2);
for (let i = 0; i < n; i++) {
  const x = arr[i];
  acc[i * 2] = x;
  acc[i * 2 + 1] = x * 2;
}
// [1, 2, 2, 4, 3, 6, 4, 8]
// 在这种特定情况下，flatMap 方法的性能比 for 循环要慢——因为需要创建临时数组并进行垃圾回收，同时返回的数组不需要经常调整大小。但是，在注重灵活性和可读性的情况下，flatMap 仍可能是正确的解决方案。
```
```js
const arr1 = [1, 2, 3, 4];
arr1.map((x) => [x * 2]);
// [[2], [4], [6], [8]]
arr1.flatMap((x) => [x * 2]);
// [2, 4, 6, 8]
// 只有一层被展平
arr1.flatMap((x) => [[x * 2]]);
// [[2], [4], [6], [8]]
const arr1 = ["it's Sunny in", "", "California"];
arr1.map((x) => x.split(" "));
// [["it's","Sunny","in"],[""],["California"]]
arr1.flatMap((x) => x.split(" "));
// ["it's","Sunny","in", "", "California"]
// callbackFn 不会被源数组中的空槽调用，因为 map() 不会调用，而 flat() 将忽略返回数组中的空槽。
console.log([1, 2, , 4, 5].flatMap((x) => [x, x * 2])); // [1, 2, 2, 4, 4, 8, 5, 10]
console.log([1, 2, 3, 4].flatMap((x) => [, x * 2])); // [2, 4, 6, 8]
```
```js
// flatMap 方法可以用作在 map 方法中添加和删除元素（修改元素数量）的方法。换句话说，它允许你将一些项处理为另一些项（通过单独处理每个输入项），而不总是一对一的。在这个意义上，它的作用类似于 filter 的相反操作。如果要保留该项，则返回一个包含该项的单元素数组，如果要添加元素，则返回一个包含多个元素的数组，如果要删除该项，则返回一个空数组。
// 假设我们想要删除所有负数，并将奇数拆分成偶数和 1
const a = [5, 4, -3, 20, 17, -33, -4, 18];
//         |\  \  x   |  | \   x   x   |
//        [4,1, 4,   20, 16, 1,       18]
const result = a.flatMap((n) => {
  if (n < 0) {
    return [];
  }
  return n % 2 === 0 ? [n] : [n - 1, 1];
});
console.log(result); // [4, 1, 4, 20, 16, 1, 18]
```
```js
const arrayLike = {
  length: 3,
  0: 1,
  1: 2,
  2: 3,
};
console.log(Array.prototype.flatMap.call(arrayLike, (x) => [x, x * 2]));
// [1, 2, 2, 4, 3, 6]
// 回调函数返回的类数组对象不会被展平
console.log(
  Array.prototype.flatMap.call(arrayLike, (x) => ({
    length: 1,
    0: x,
  })),
);
// [ { '0': 1, length: 1 }, { '0': 2, length: 1 }, { '0': 3, length: 1 } ]
```

### `forEach(callbackFn, thisArg)`: 对调用数组中的每个元素调用给定的函数。
- callbackFn 为数组中每个元素执行的函数。并会丢弃它的返回值。该函数被调用时将传入以下参数：
  - element 数组中正在处理的当前元素。
  - index 数组中正在处理的当前元素的索引。
  - array 调用了 forEach() 的数组本身。
- thisArg 可选 执行 callbackFn 时用作 this 的值。
- 返回值 undefined。
- forEach() 方法是一个迭代方法。它按索引升序地为数组中的每个元素调用一次提供的 callbackFn 函数。与 map() 不同，forEach() 总是返回 undefined，而且不能继续链式调用。其典型的用法是在链式调用的末尾执行某些操作。
- callbackFn 仅对已赋值的数组索引调用。对于稀疏数组中的空槽，它不会被调用。
- forEach() 不会改变其调用的数组，但是，作为 callbackFn 的函数可以更改数组。请注意，在第一次调用 callbackFn 之前，数组的长度已经被保存。因此：
  - 当调用 forEach() 时，callbackFn 不会访问超出数组初始长度的任何元素。
  - 已经访问过的索引的更改不会导致 callbackFn 再次调用它们。
  - 如果 callbackFn 更改了数组中已经存在但尚未访问的元素，则传递给 callbackFn 的值将是在访问该元素时的值。已经被删除的元素不会被访问。
- forEach() 方法是通用的。它只期望 this 值具有 length 属性和整数键的属性。
- 除非抛出异常，否则没有办法停止或中断 forEach() 循环。如果有这样的需求，则不应该使用 forEach() 方法。
- 可以通过像 for、for...of 和 for...in 这样的循环语句来实现提前终止。当不需要进一步迭代时，诸如 every()、some()、find() 和 findIndex() 等数组方法也会立即停止迭代。
- forEach() 期望的是一个同步函数，它不会等待 Promise 兑现。在使用 Promise（或异步函数）作为 forEach 回调时，请确保你意识到这一点可能带来的影响。
```js
const ratings = [5, 4, 5];
let sum = 0;
const sumFunction = async (a, b) => a + b;
ratings.forEach(async (rating) => {
  sum = await sumFunction(sum, rating);
});
console.log(sum);
// 期望的输出：14
// 实际的输出：0
const arraySparse = [1, 3, /* empty */, 7];
let numCallbackRuns = 0;
arraySparse.forEach((element) => {
  console.log({ element });
  numCallbackRuns++;
});
console.log({ numCallbackRuns });
// { element: 1 }
// { element: 3 }
// { element: 7 }
// { numCallbackRuns: 3 }
// 缺失值不会被调用回调函数
```
```js
const words = ["one", "two", "three", "four"];
words.forEach((word) => {
  console.log(word);
  if (word === "two") {
    words.shift(); //'one' 将从数组中删除
  }
}); // one // two // four
console.log(words); // ['two', 'three', 'four']
```
```js
const flatten = (arr) => {
  const result = [];
  arr.forEach((item) => {
    if (Array.isArray(item)) {
      result.push(...flatten(item));
    } else {
      result.push(item);
    }
  });
  return result;
};
// 用例
const nested = [1, 2, 3, [4, 5, [6, 7], 8, 9]];
console.log(flatten(nested)); // [1, 2, 3, 4, 5, 6, 7, 8, 9]
```

### `includes(searchElement, fromIndex)`: 用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回 false。
- searchElement 需要查找的值。
- fromIndex 可选，开始搜索的索引（从零开始），会转换为整数。
  - 负索引从数组末尾开始计数——如果 fromIndex < 0，那么实际使用的是 fromIndex + array.length。然而在这种情况下，数组仍然从前往后进行搜索。
  - 如果 fromIndex < -array.length 或者省略 fromIndex，则使用 0，这将导致整个数组被搜索。
  - 如果 fromIndex >= array.length，则不会搜索数组并返回 false。
- 返回一个布尔值，如果在数组中（或者在 fromIndex 所指示的数组部分中，如果指定 fromIndex 的话）找到 searchElement 值，则该值为 true。
- includes() 方法使用零值相等算法将 searchElement 与数组中的元素进行比较。0 值都被认为是相等的，不管符号是什么。（即 -0 等于 0），但 false 不被认为与 0 相同。NaN 可以被正确搜索到。
- 当在稀疏数组上使用时，includes() 方法迭代空槽，就像它们的值是 undefined 一样。
- includes() 方法是通用的。它只期望 this 值具有 length 属性和整数键属性。
- 如果 fromIndex 大于等于数组的长度，则将直接返回 false，且不搜索该数组。
```js
[1, 2, 3].includes(2); // true
[1, 2, 3].includes(4); // false
[1, 2, 3].includes(3, 3); // false
[1, 2, 3].includes(3, -1); // true
[1, 2, NaN].includes(NaN); // true
["1", "2", "3"].includes(3); // false
const arr = ["a", "b", "c"];
arr.includes("c", 3); // false
arr.includes("c", 100); // false
// 数组长度为 3
// fromIndex 为 -100
// 计算出的索引为 3 + (-100) = -97
const arr = ["a", "b", "c"];
arr.includes("a", -100); // true
arr.includes("b", -100); // true
arr.includes("c", -100); // true
arr.includes("a", -2); // false
console.log([1, , 3].includes(undefined)); // true
const arrayLike = {
  length: 3,
  0: 2,
  1: 3,
  2: 4,
};
console.log(Array.prototype.includes.call(arrayLike, 2)); // true
console.log(Array.prototype.includes.call(arrayLike, 1)); // false
```

### `indexOf(searchElement, fromIndex)`: 返回在调用数组中可以找到给定元素的第一个（最小）索引。
- searchElement 数组中要查找的元素。
- fromIndex 可选 开始搜索的索引（从零开始），会转换为整数。
  - 负索引从数组末尾开始计数——如果 frommindex < 0，使用 frommindex + array.length。注意，在这种情况下，仍然从前到后搜索数组。
  - 如果 fromIndex < -array.length 或者省略了 fromIndex ，将使用 0，而导致整个数组被搜索。
  - 如果 fromIndex >= array.length，数组不会继续搜索并返回 -1。
- 返回值 首个被找到的元素在数组中的索引位置; 若没有找到则返回 -1。
- indexOf() 使用严格相等（与 === 运算符使用的算法相同）将 searchElement 与数组中的元素进行比较。NaN 值永远不会被比较为相等，因此当 searchElement 为 NaN 时 indexOf() 总是返回 -1。
- indexOf() 方法会跳过稀疏数组中的空槽。
- indexOf() 方法是通用的。它只期望 this 值具有 length 属性和整数键属性。
```js
const array = [2, 9, 9, NaN];
array.indexOf(2); // 0
array.indexOf(7); // -1
array.indexOf(9, 2); // 2
array.indexOf(2, -1); // -1
array.indexOf(2, -3); // 0
array.indexOf(NaN); // -1
console.log([1, , 3].indexOf(undefined)); // -1
const arrayLike = {
  length: 3,
  0: 2,
  1: 3,
  2: 4,
};
console.log(Array.prototype.indexOf.call(arrayLike, 2));
// 0
console.log(Array.prototype.indexOf.call(arrayLike, 5));
// -1
```
```js
// 找出指定元素出现的所有位置
const indices = [];
const array = ["a", "b", "a", "c", "a", "d"];
const element = "a";
let idx = array.indexOf(element);
while (idx !== -1) {
  indices.push(idx);
  idx = array.indexOf(element, idx + 1);
}
console.log(indices);
// [0, 2, 4]
```

### `join(separator)`: 将一个数组（或一个类数组对象）的所有元素连接成一个字符串并返回这个字符串，用逗号或指定的分隔符字符串分隔。如果数组只有一个元素，那么将返回该元素而不使用分隔符。
- separator 可选 指定一个字符串来分隔数组的每个元素。如果需要，将分隔符转换为字符串。如果省略，数组元素用逗号（,）分隔。如果 separator 是空字符串（""），则所有元素之间都没有任何字符。
- 返回值 一个所有数组元素连接的字符串。如果 arr.length 为 0，则返回空字符串。
- 所有数组元素被转换成字符串并连接到一个字符串中。如果一个元素是 undefined 或 null，它将被转换为空字符串，而不是字符串 "undefined" 或 "null"。
- Array.prototype.toString() 会在内部访问 join 方法，不带参数。覆盖一个数组实例的 join 也将覆盖它的 toString 行为。
- 当在稀疏数组上使用时，join() 方法迭代空槽，就像它们的值为 undefined 一样。
- join() 方法是通用的。它只期望 this 值具有 length 属性和整数键属性。
```js
const a = ["Wind", "Water", "Fire"];
a.join(); // 'Wind,Water,Fire'
a.join(", "); // 'Wind, Water, Fire'
a.join(" + "); // 'Wind + Water + Fire'
a.join(""); // 'WindWaterFire'
// join() 将空槽视为 undefined，并产生额外的分隔符
console.log([1, , 3].join()); // '1,,3'
console.log([1, undefined, 3].join()); // '1,,3'
// join() 方法读取 this 的 length 属性，然后访问每个整数索引
const arrayLike = {
  length: 3,
  0: 2,
  1: 3,
  2: 4,
};
console.log(Array.prototype.join.call(arrayLike));
// 2,3,4
console.log(Array.prototype.join.call(arrayLike, "."));
// 2.3.4
```

### `keys()`: 返回一个新的数组迭代器，其中包含调用数组中每个索引的键。
- 返回值 一个新的可迭代迭代器对象 (en-US)。
- 当用于稀疏数组时，keys() 方法迭代空槽，就像它们的值为 undefined 一样。
- keys() 方法是通用的。它只期望 this 值具有 length 属性和整数键属性。
- 与 Object.keys() 只包含数组中实际存在的键不同，keys() 迭代器不会忽略缺失属性的键。
```js
const arr = ["a", , "c"];
const sparseKeys = Object.keys(arr);
const denseKeys = [...arr.keys()];
console.log(sparseKeys); // ['0', '2']
console.log(denseKeys); // [0, 1, 2]
//
const arrayLike = {
  length: 3,
};
for (const entry of Array.prototype.keys.call(arrayLike)) {
  console.log(entry);
}
// 0
// 1
// 2
```

### `lastIndexOf(searchElement, fromIndex)`: 返回数组中给定元素最后一次出现的索引，如果不存在则返回 -1。该方法从 fromIndex 开始向前搜索数组。
- searchElement 被查找的元素。
- fromIndex 可选 以 0 起始的索引，表明反向搜索的起始位置，会被转换为整数。
  - 如果 fromIndex < 0，则从数组末尾开始倒数计数——即使用 fromIndex + array.length 的值。
  - 如果 fromIndex < -array.length，则不搜索数组并返回 -1。从概念上讲，你可以把它想象成从数组开始之前不存在的位置开始反向搜索，这条路径上没有任何数组元素，因此 searchElement 永远不会被找到。
  - 如果 fromIndex >= array.length 或者省略了 fromIndex，则使用 array.length - 1，这会导致搜索整个数组。可以将其理解为从数组尾部之后不存在的位置开始向前搜索。最终会访问到数组最后一个元素，并继续向前开始实际搜索数组元素。
- 返回值 数组中该元素最后一次出现的索引，如未找到返回 -1。
- lastIndexOf 使用严格相等（与 === 运算符使用的算法相同）比较 searchElement 和数组中的元素。NaN 值永远不会被比较为相等，因此当 searchElement 为 NaN 时 lastIndexOf() 总是返回 -1。
- lastIndexOf() 方法会跳过稀疏数组中的空槽。
- lastIndexOf() 方法是通用的。它只期望 this 值具有 length 属性和整数键属性。
```js
const numbers = [2, 5, 9, 2];
numbers.lastIndexOf(2); // 3
numbers.lastIndexOf(7); // -1
numbers.lastIndexOf(2, 3); // 3
numbers.lastIndexOf(2, 2); // 0
numbers.lastIndexOf(2, -2); // 0
numbers.lastIndexOf(2, -1); // 3
const array = [NaN];
array.lastIndexOf(NaN); // -1
console.log([1, , 3].lastIndexOf(undefined)); // -1
const arrayLike = {
  length: 3,
  0: 2,
  1: 3,
  2: 2,
};
console.log(Array.prototype.lastIndexOf.call(arrayLike, 2));
// 2
console.log(Array.prototype.lastIndexOf.call(arrayLike, 5));
// -1
```
```js
const indices = [];
const array = ["a", "b", "a", "c", "a", "d"];
const element = "a";
let idx = array.lastIndexOf(element);
while (idx !== -1) {
  indices.push(idx);
  idx = idx > 0 ? array.lastIndexOf(element, idx - 1) : -1;
}
console.log(indices);
// [4, 2, 0]
```

### `map(callbackFn, thisArg)`: 创建一个新数组，这个新数组由原数组中的每个元素都调用一次提供的函数后的返回值组成。
- callbackFn 为数组中的每个元素执行的函数。它的返回值作为一个元素被添加为新数组中。该函数被调用时将传入以下参数：
  - element 数组中当前正在处理的元素。
  - index 正在处理的元素在数组中的索引。
  - array 调用了 map() 的数组本身。
- thisArg 可选 执行 callbackFn 时用作 this 的值。
- 返回值 一个新数组，每个元素都是回调函数的返回值。
- map() 方法是一个迭代方法。它为数组中的每个元素调用一次提供的 callbackFn 函数，并用结果构建一个新数组。
- callbackFn 仅在已分配值的数组索引处被调用。它不会在稀疏数组中的空槽处被调用。
- map() 方法是一个复制方法。它不会改变 this。然而，作为 callbackFn 提供的函数可以更改数组。请注意，在第一次调用 callbackFn 之前，数组的长度已经被保存。因此：
  - 当开始调用 map() 时，callbackFn 将不会访问超出数组初始长度的任何元素。
  - 对已访问索引的更改不会导致再次在这些元素上调用 callbackFn。
  - 如果数组中一个现有的、尚未访问的元素被 callbackFn 更改，则它传递给 callbackFn 的值将是该元素被修改后的值。被删除的元素则不会被访问。
- map() 方法是通用的。它只期望 this 值具有 length 属性和整数键属性。
- 由于 map 创建一个新数组，在没有使用返回的数组的情况下调用它是不恰当的；应该使用 forEach 或 for...of 作为代替。
```js
const numbers = [1, 4, 9];
const roots = numbers.map((num) => Math.sqrt(num));
// roots 现在是     [1, 2, 3]
// numbers 依旧是   [1, 4, 9]
const kvArray = [
  { key: 1, value: 10 },
  { key: 2, value: 20 },
  { key: 3, value: 30 },
];
const reformattedArray = kvArray.map(({ key, value }) => ({ [key]: value }));
console.log(reformattedArray); // [{ 1: 10 }, { 2: 20 }, { 3: 30 }]
console.log(kvArray);
// [
//   { key: 1, value: 10 },
//   { key: 2, value: 20 },
//   { key: 3, value: 30 }
// ]
const arrayLike = {
  length: 3,
  0: 2,
  1: 3,
  2: 4,
};
console.log(Array.prototype.map.call(arrayLike, (x) => x ** 2));
// [ 4, 9, 16 ]
console.log(
  [1, , 3].map((x, index) => {
    console.log(`Visit ${index}`);
    return x * 2;
  }),
);
// Visit 0
// Visit 2
// [2, empty, 6]
```
```js
const numbers = [1, 2, 3, 4];
const filteredNumbers = numbers.map((num, index) => {
  if (index < 3) {
    return num;
  }
});
// index 从 0 开始，因此 filterNumbers 为 1、2、3 和 undefined。
// filteredNumbers 是 [1, 2, 3, undefined]
// numbers 依旧是 [1, 2, 3, 4]
```

### `pop()`: 从数组中删除最后一个元素，并返回该元素的值。此方法会更改数组的长度。
- 返回值 从数组中删除的元素（当数组为空时返回 undefined）。
- pop() 方法从一个数组中删除并返回最后一个元素给调用者。如果你在空数组上调用 pop()，它会返回 undefined。
- Array.prototype.shift() 和 pop() 有类似的行为，但是它是作用在数组的第一个元素上的。
- pop() 是修改方法。其改变了 this 的长度和内容。如果你想要 this 不变，但是返回一个新的最后一个元素被移除的数组，你可以使用 arr.slice(0, -1) 来代替。
- pop() 方法是通用的。它只期望 this 值具有 length 属性和整数键属性。虽然字符串也是类数组对象，但是由于其不能被修改，所以 pop() 方法并不能应用在字符串上。
```js
const myFish = ["angel", "clown", "mandarin", "sturgeon"];
const popped = myFish.pop();
console.log(myFish); // ['angel', 'clown', 'mandarin' ]
console.log(popped); // 'sturgeon'
//
// pop() 方法会读取 this 上的 length 属性。如果规范化的 length 属性为 0，length 会被再次设置为 0（鉴于之前可能是负数或者 undefined）。否则，返回并删除位于 length - 1 处的属性。
const arrayLike = {
  length: 3,
  unrelated: "foo",
  2: 4,
};
console.log(Array.prototype.pop.call(arrayLike));
// 4
console.log(arrayLike);
// { length: 2, unrelated: 'foo' }
const plainObj = {};
// 没有 length 属性，所以长度为 0
Array.prototype.pop.call(plainObj);
console.log(plainObj);
// { length: 0 }
```
```js
const collection = {
  length: 0,
  addElements(...elements) {
    // 每次添加元素时
    // obj.length 都会自动增加
    // 返回 push 方法的返回值，即 length 属性的新值
    return [].push.call(this, ...elements);
  },
  removeElement() {
    // 每次移除元素时
    // obj.length 都会自动减少
    // 返回 pop 方法的返回值，即被移除的元素
    return [].pop.call(this);
  },
};
collection.addElements(10, 20, 30);
console.log(collection.length); // 3
collection.removeElement();
console.log(collection.length); // 2
```

### `push(element0, element1, /* … ,*/ elementN)`: 将指定的元素添加到数组的末尾，并返回新的数组长度。
- elementN 添加到数组末尾的元素。
- 返回值 调用方法的对象的新 length 属性。
- push() 方法将值追加到一个数组中。
- Array.prototype.unshift() 有着和 push() 相似的行为，但是其作用于数组的开头。
- push() 方法是一个修改方法。它改变了 this 的内容和长度。如果你希望 this 的值保持不变，但返回一个末尾追加了元素的新数组，你可以使用 arr.concat([element0, element1, /* ... ,*/ elementN]) 来代替。请注意，这些元素需要被包装在一个额外的数组中——否则，如果元素本身是一个数组，由于 concat() 的行为，它将被展开而不是作为单个元素添加到原数组的末尾。
- push() 方法是通用的。它只期望 this 值具有 length 属性和整数键属性。虽然字符串也是类似数组的，但这个方法不适用于它，因为字符串是不可变的。
```js
const sports = ["soccer", "baseball"];
const total = sports.push("football", "swimming");
console.log(sports); // ['soccer', 'baseball', 'football', 'swimming']
console.log(total); // 4
const vegetables = ["parsnip", "potato"];
const moreVegs = ["celery", "beetroot"];
// 合并第二个数组到第一个数组中
vegetables.push(...moreVegs);
console.log(vegetables); // ['parsnip', 'potato', 'celery', 'beetroot']
const arrayLike = {
  length: 3,
  unrelated: "foo",
  2: 4,
};
Array.prototype.push.call(arrayLike, 1, 2);
console.log(arrayLike);
// { '2': 4, '3': 1, '4': 2, length: 5, unrelated: 'foo' }
const plainObj = {};
// 这里没有长度属性，所以长度为 0
Array.prototype.push.call(plainObj, 1, 2);
console.log(plainObj);
// { '0': 1, '1': 2, length: 2 }
const obj = {
  length: 0,
  addElem(elem) {
    // obj.length 在每次添加元素时自动增加
    [].push.call(this, elem);
  },
};
// 让我们添加一些空对象来说明
obj.addElem({});
obj.addElem({});
console.log(obj.length); // 2
```

### `reduce(callbackFn, initialValue)`: 对数组的每个元素（从左到右）执行用户提供的“reducer”回调函数，将其简化为单个值。
- callbackFn 为数组中每个元素执行的函数。其返回值将作为下一次调用 callbackFn 时的 accumulator 参数。对于最后一次调用，返回值将作为 reduce() 的返回值。该函数被调用时将传入以下参数：
  - accumulator 上一次调用 callbackFn 的结果。在第一次调用时，如果指定了 initialValue 则为指定的值，否则为 array[0] 的值。
  - currentValue 当前元素的值。在第一次调用时，如果指定了 initialValue，则为 array[0] 的值，否则为 array[1]。
  - currentIndex currentValue 在数组中的索引位置。在第一次调用时，如果指定了 initialValue 则为 0，否则为 1。
  - array 调用了 reduce() 的数组本身。
- initialValue 可选 第一次调用回调时初始化 accumulator 的值。如果指定了 initialValue，则 callbackFn 从数组中的第一个值作为 currentValue 开始执行。如果没有指定 initialValue，则 accumulator 初始化为数组中的第一个值，并且 callbackFn 从数组中的第二个值作为 currentValue 开始执行。在这种情况下，如果数组为空（没有第一个值可以作为 accumulator 返回），则会抛出错误。
- 返回值 使用“reducer”回调函数遍历整个数组后的结果。
- 异常 TypeError 如果数组为空且未提供 initialValue，则会抛出异常。
- reduce() 方法对数组中的每个元素按序执行一个提供的 reducer 函数，每一次运行 reducer 会将先前元素的计算结果作为参数传入，最后将其结果汇总为单个返回值。
- 第一次执行回调函数时，不存在“上一次的计算结果”。如果需要回调函数从数组索引为 0 的元素开始执行，则需要传递初始值。否则，数组索引为 0 的元素将被用作初始值，迭代器将从第二个元素开始执行（即从索引为 1 而不是 0 的位置开始）。
- reduce() 方法是一个迭代方法。它按升序对数组中的所有元素运行一个“reducer”回调函数，并将它们累积到一个单一的值中。每次调用时，callbackFn 的返回值都作为 accumulator 参数传递到下一次调用中。accumulator 的最终值（也就是在数组的最后一次迭代中从 callbackFn 返回的值）将作为 reduce() 的返回值。
- callbackFn 仅对已分配值的数组索引进行调用。不会对稀疏数组中的空槽进行调用。
- 与其他迭代方法不同，reduce() 不接受 thisArg 参数。callbackFn 调用时始终以 undefined 作为 this 的值，如果 callbackFn 未处于严格模式，则该值将被替换为 globalThis。
- reduce() 是函数式编程中的一个核心概念，在函数式编程中，不可能改变任何值，因此为了累积数组中的所有值，必须在每次迭代中返回一个新的累加器。这种约定也适用于 JavaScript 的 reduce()：应该在可能的情况下使用展开语法或其他复制方法来创建新的数组和对象作为累加器，而不是改变现有的累加器。如果你决定改变累加器而不是复制它，请记得仍然在回调中返回修改后的对象，否则下一次迭代将收到 undefined。
- reduce() 不会改变被调用的数组，但是作为 callbackFn 提供的函数可能会改变数组。但需要注意的是，在第一次调用 callbackFn 之前，数组的长度会被保存。因此：
  - 当开始调用 reduce() 时，callbackFn 将不会访问超出数组初始长度的任何元素。
  - 已访问索引的更改不会导致再次在这些元素上调用 callbackFn。
  - 如果数组中一个现有的、尚未访问的元素被 callbackFn 更改，则它传递给 callbackFn 的值将是该元素被修改后的值。被删除的元素则不会被访问。
- reduce() 方法是通用的。它只期望 this 值具有 length 属性和整数键属性。
- 像 reduce() 这样的递归函数可能非常强大，但有时可能很难理解，特别是对于缺乏经验的 JavaScript 开发人员。如果使用其他数组方法可以使代码更清晰，则开发人员必须权衡代码可读性与使用 reduce() 带来的好处。如果 reduce() 确实是最佳选择，应该通过良好的文档和语义化的变量命名来提高代码的可读性。
- 如果数组只有一个元素（无论位置如何）且未提供 initialValue，或者提供了 initialValue 但数组为空，则将返回该单个值，而不调用 callbackFn。
- 如果提供了 initialValue 且数组不为空，则 reduce 方法将始终从索引 0 开始调用回调函数。
- 如果未提供 initialValue，则对于长度大于 1、等于 1 和 0 的数组，reduce 方法将有不同的表现，如以下示例所示：
```js
const getMax = (a, b) => Math.max(a, b);
// 从索引 0 开始为数组中的每个元素调用回调函数
[1, 100].reduce(getMax, 50); // 100
[50].reduce(getMax, 10); // 50
// 仅为索引 1 处的元素调用回调函数
[1, 100].reduce(getMax); // 100
// 不调用回调函数
[50].reduce(getMax); // 50
[].reduce(getMax, 1); // 1
[].reduce(getMax); // TypeError
```
```js
const array = [15, 16, 17, 18, 19];
function reducer(accumulator, currentValue, index) {
  const returns = accumulator + currentValue;
  console.log(
    `accumulator: ${accumulator}, currentValue: ${currentValue}, index: ${index}, returns: ${returns}`,
  );
  return returns;
}
array.reduce(reducer);
// 回调函数会被调用四次，每次调用的参数和返回值如下：
//              accumulator	currentValue	index	返回值
// 第一次调用	        15	        16	        1	   31
// 第二次调用	        31	        17	        2	   48
// 第三次调用	        48	        18	        3	   66
// 第四次调用	        66	        19	        4	   85
// array 参数在整个过程中始终不会改变——它始终是 [15, 16, 17, 18, 19]。reduce() 返回的值将是最后一次回调返回值（85）。
```
```js
[15, 16, 17, 18, 19].reduce(
  (accumulator, currentValue) => accumulator + currentValue,
  10,
);
// 回调函数会被调用五次，每次调用的参数和返回值如下表：
//            accumulator	currentValue	index	返回值
// 第一次调用	      10	         15 	      0	   25
// 第二次调用	      25	         16 	      1	   41
// 第三次调用	      41	         17 	      2	   58
// 第四次调用	      58	         18 	      3	   76
// 第五次调用	      76	         19 	      4	   95
// 这种情况下 reduce() 返回的值是 95。
```
```js
// 求对象数组中值的总和
const objects = [{ x: 1 }, { x: 2 }, { x: 3 }];
const sum = objects.reduce(
  (accumulator, currentValue) => accumulator + currentValue.x,
  0,
);
console.log(sum); // 6
```
```js
// 展平嵌套数组
const flattened = [
  [0, 1],
  [2, 3],
  [4, 5],
].reduce((accumulator, currentValue) => accumulator.concat(currentValue), []);
// flattened 的值是 [0, 1, 2, 3, 4, 5]
```
```js
// 统计对象中值的出现次数
const names = ["Alice", "Bob", "Tiff", "Bruce", "Alice"];
const countedNames = names.reduce((allNames, name) => {
  const currCount = allNames[name] ?? 0;
  return {
    ...allNames,
    [name]: currCount + 1,
  };
}, {});
// countedNames 的值是：
// { 'Alice': 2, 'Bob': 1, 'Tiff': 1, 'Bruce': 1 }
```
```js
// 按属性对对象进行分组
const people = [
  { name: "Alice", age: 21 },
  { name: "Max", age: 20 },
  { name: "Jane", age: 20 },
];
function groupBy(objectArray, property) {
  return objectArray.reduce((acc, obj) => {
    const key = obj[property];
    const curGroup = acc[key] ?? [];

    return { ...acc, [key]: [...curGroup, obj] };
  }, {});
}
const groupedPeople = groupBy(people, "age");
console.log(groupedPeople);
// {
//   20: [
//     { name: 'Max', age: 20 },
//     { name: 'Jane', age: 20 }
//   ],
//   21: [{ name: 'Alice', age: 21 }]
// }
```
```js
// 使用展开语法和 initialValue 连接包含在对象数组中的数组
// friends——一个对象数组，其中对象字段“books”是最喜欢的书的列表
const friends = [
  {
    name: "Anna",
    books: ["Bible", "Harry Potter"],
    age: 21,
  },
  {
    name: "Bob",
    books: ["War and peace", "Romeo and Juliet"],
    age: 26,
  },
  {
    name: "Alice",
    books: ["The Lord of the Rings", "The Shining"],
    age: 18,
  },
];
// allbooks——列表，其中包含所有朋友的书籍和 initialValue 中包含的附加列表
const allbooks = friends.reduce(
  (accumulator, currentValue) => [...accumulator, ...currentValue.books],
  ["Alphabet"],
);
console.log(allbooks);
// [
//   'Alphabet', 'Bible', 'Harry Potter', 'War and peace',
//   'Romeo and Juliet', 'The Lord of the Rings',
//   'The Shining'
// ]
```
```js
// 数组去重
// 可以使用 Set 和 Array.from() 来实现相同的效果，如 const arrayWithNoDuplicates = Array.from(new Set(myArray))，并且性能更好。
//
const myArray = ["a", "b", "a", "b", "c", "e", "e", "c", "d", "d", "d", "d"];
const myArrayWithNoDuplicates = myArray.reduce((accumulator, currentValue) => {
  if (!accumulator.includes(currentValue)) {
    return [...accumulator, currentValue];
  }
  return accumulator;
}, []);
console.log(myArrayWithNoDuplicates);
```
```js
// 使用 reduce() 来替代 .filter().map()
// 使用 filter() 和 map() 会遍历数组两次，但是你可以使用 reduce() 只遍历一次并实现相同的效果，从而更高效。（如果你喜欢使用 for 循环，你可以在遍历一次时使用 forEach() 进行过滤和映射。）
const numbers = [-5, 6, 2, 0];
const doubledPositiveNumbers = numbers.reduce((accumulator, currentValue) => {
  if (currentValue > 0) {
    const doubled = currentValue * 2;
    return [...accumulator, doubled];
  }
  return accumulator;
}, []);
console.log(doubledPositiveNumbers); // [12, 4]
```
```js
// 按顺序运行 Promise
/**
 * 链接一系列 Promise 处理程序。
 *
 * @param {array} arr——一个 Promise 处理程序列表，每个处理程序接收前一个处理程序解决的结果并返回另一个 Promise。
 * @param {*} input——开始调用 Promise 链的初始值
 * @return {Object}——由一系列 Promise 链接而成的 Promise
 */
function runPromiseInSequence(arr, input) {
  return arr.reduce(
    (promiseChain, currentFunction) => promiseChain.then(currentFunction),
    Promise.resolve(input),
  );
}
// Promise 函数 1
function p1(a) {
  return new Promise((resolve, reject) => {
    resolve(a * 5);
  });
}
// Promise 函数 2
function p2(a) {
  return new Promise((resolve, reject) => {
    resolve(a * 2);
  });
}
// 函数 3——将由 `.then()` 包装在已解决的 Promise 中
function f3(a) {
  return a * 3;
}
// Promise 函数 4
function p4(a) {
  return new Promise((resolve, reject) => {
    resolve(a * 4);
  });
}
const promiseArr = [p1, p2, f3, p4];
runPromiseInSequence(promiseArr, 10).then(console.log); // 1200
```
```js
// 使用函数组合实现管道
// 组合使用的构建块
const double = (x) => 2 * x;
const triple = (x) => 3 * x;
const quadruple = (x) => 4 * x;
// 函数组合，实现管道功能
const pipe =
  (...functions) =>
  (initialValue) =>
    functions.reduce((acc, fn) => fn(acc), initialValue);
// 组合的函数，实现特定值的乘法
const multiply6 = pipe(double, triple);
const multiply9 = pipe(triple, triple);
const multiply16 = pipe(quadruple, quadruple);
const multiply24 = pipe(double, triple, quadruple);
// 用例
multiply6(6); // 36
multiply9(9); // 81
multiply16(16); // 256
multiply24(10); // 240
```
```js
// 在稀疏数组中使用 reduce()
// reduce() 会跳过稀疏数组中缺失的元素，但不会跳过 undefined 值。
console.log([1, 2, , 4].reduce((a, b) => a + b)); // 7
console.log([1, 2, undefined, 4].reduce((a, b) => a + b)); // NaN
```
```js
// 在非数组对象上调用 reduce()
// reduce() 方法读取 this 的 length 属性，然后访问每个整数索引。
const arrayLike = {
  length: 3,
  0: 2,
  1: 3,
  2: 4,
};
console.log(Array.prototype.reduce.call(arrayLike, (x, y) => x + y));
// 9
```

### `reduceRight(callbackFn, initialValue)`: 对数组的每个元素（从右到左）执行用户提供的“reducer”回调函数，将其简化为单个值。
- callbackFn 为数组中的每个元素执行的函数。其返回值将作为下一次调用 callbackFn 时的 accumulator 参数。对于最后一次调用，返回值将成为 reduceRight() 的返回值。该函数被调用时将传入以下参数：
  - accumulator 上一次调用 callbackFn 的结果。在第一次调用时，如果指定了 initialValue 则为指定的值，否则为数组最后一个元素的值。
  - currentValue 数组中当前正在处理的元素。
  - index 正在处理的元素在数组中的索引。
  - array 调用了 reduceRight() 的数组本身。
- initialValue 可选 首次调用 callbackFn 时累加器的值。如果不提供初始值，则将使用数组中的最后一个元素，并在迭代时跳过它。没有初始值的情况下，在空数组上调用 reduceRight() 会产生 TypeError。
- reduceRight() 方法对累加器（accumulator）和数组的每个值（按从右到左的顺序）应用一个函数，并使其成为单个值。
- 返回值 聚合后的结果值。
- reduceRight() 方法是一个迭代方法。它为数组中的所有元素降序调用“reducer”回调函数，并将它们累积到一个单一的值中。
- callbackFn 仅为已分配值的数组索引调用。它不会为稀疏数组中的空槽调用。
- 与其他迭代方法不同，reduceRight() 不接受 thisArg 参数。callbackFn 调用时始终以 undefined 作为 this 的值，如果 callbackFn 未处于严格模式，则该值将被替换为 globalThis。
- reduceRight() 不会改变被调用的数组，但是作为 callbackFn 提供的函数可能会改变数组。但需要注意的是，在第一次调用 callbackFn 之前，数组的长度会被保存。因此：
  - 当开始调用 reduceRight() 时，callbackFn 将不会访问超出数组初始长度的任何元素。
  - 对已访问索引的更改不会导致再次在这些元素上调用 callbackFn。
  - 如果数组中一个现有的、尚未访问的元素被 callbackFn 更改，则它传递给 callbackFn 的值将是该元素被修改后的值。被删除的元素则不会被访问。
- reduceRight() 方法是通用的。它只期望 this 值具有 length 属性和整数键属性。
- 在第一次调用函数时，accumulator 和 currentValue 的可能取值情况有两种。如果在调用 reduceRight 时提供了 initialValue，那么 accumulator 将等于 initialValue，而 currentValue 将等于数组中的最后一个值。如果没有提供 initialValue，则 accumulator 将等于数组中的最后一个值，而 currentValue 将等于倒数第二个值。
- 如果数组为空且没有提供 initialValue，则会抛出 TypeError 异常。如果数组只有一个元素（无论其位置如何）且没有提供 initialValue，或者提供了 initialValue 但数组为空，则直接返回该单个值，且 callbackFn 不会被调用。
```js
[0, 1, 2, 3, 4].reduceRight(
  (accumulator, currentValue, index, array) => accumulator + currentValue,
);
// 一共会调用四次回调函数，每次调用的参数及返回值如下：
//            accumulator	currentValue	index	返回值
// 第一次调用	       4	         3	        3	    7
// 第二次调用	       7	         2	        2	    9
// 第三次调用	       9	         1	        1	    10
// 第四次调用	       10        	 0       	  0  	  10
// array 参数在整个过程中始终不变，始终为 [0, 1, 2, 3, 4]。reduceRight 返回的值将是最后一次回调函数调用的返回值（10）。
```
```js
[0, 1, 2, 3, 4].reduceRight(
  (accumulator, currentValue, index, array) => accumulator + currentValue,
  10,
);
// 	          accumulator	currentValue	index	返回值
// 第一次调用	      10	        4	          4   	14
// 第二次调用	      14	        3	          3   	17
// 第三次调用	      17	        2	          2   	19
// 第四次调用	      19	        1	          1   	20
// 第五次调用	      20	        0	          0   	20
// 这次，reduceRight 返回值为 20。
```
```js
// 函数组合是一种将函数组合在一起的机制，其中每个函数的输出都作为下一个函数的输入，最后一个函数的输出是最终的结果。
const compose =
  (...args) =>
  (value) =>
    args.reduceRight((acc, fn) => fn(acc), value);
// Increment passed number
const inc = (n) => n + 1;
// Doubles the passed value
const double = (n) => n * 2;
// using composition function
console.log(compose(double, inc)(2)); // 6
// using composition function
console.log(compose(inc, double)(2)); // 5
```

### `reverse()`: 就地反转数组中的元素，并返回同一数组的引用。数组的第一个元素会变成最后一个，数组的最后一个元素变成第一个。换句话说，数组中的元素顺序将被翻转，变为与之前相反的方向。要在不改变原始数组的情况下反转数组中的元素，使用 toReversed()。
- 返回值 原始数组反转后的引用。注意，数组是就地反转的，并且没有复制。
- reverse 方法反转数组中元素的位置，改变了数组，并返回该数组的引用。
- reverse() 方法会保留空槽。如果源数组是稀疏的，则空槽对应的新索引将被删除，并且也成为空槽。
- reverse() 方法是通用的。它只期望 this 值具有 length 属性和整数键属性。虽然字符串也是类似于数组的，但这个方法不适用于它们，因为字符串是不可变的。
- 对非数组对象调用 reverse() 时，reverse() 方法读取 this 的 length 属性。然后，它访问 0 和 length / 2 之间的每个索引，并交换两端对应的两个索引，并在必要时，删除某些属性。
```js
const items = [1, 2, 3];
console.log(items); // [1, 2, 3]
items.reverse();
console.log(items); // [3, 2, 1]
console.log([1, , 3].reverse()); // [3, empty, 1]
console.log([1, , 3, 4].reverse()); // [4, 3, empty, 1]
const arrayLike = {
  length: 3,
  unrelated: "foo",
  2: 4,
};
console.log(Array.prototype.reverse.call(arrayLike));
// { '0': 4, length: 3, unrelated: 'foo' }
// 索引“2”被删除了，因为原本的数据中索引“0”不存在了
```

### `shift()`: 从数组中删除第一个元素，并返回该元素的值。此方法更改数组的长度。
- 返回值 从数组中删除的元素；如果数组为空则返回 undefined。
- shift 方法移除索引为 0 的元素，并将后续元素的下标依次向前移动，然后返回被移除的元素。如果 length 属性的值为 0，则返回 undefined。
- pop() 方法有着和 shift() 相似的行为。但是是作用于数组的最后一个元素上的。
- shift() 方法是一个改变方法。它改变了 this 的内容和长度。如果你希望保持 this 的值不变，但返回一个删除了第一个元素的新数组，你可以使用 arr.slice(1)。
- shift() 方法是通用的。它只期望 this 值具有 length 属性和整数键属性。虽然字符串也是类似数组的，但这个方法不适合应用于它们，因为字符串是不可变的。
- shift 方法会读取 this 的 length 属性。如果规范化长度为 0，length 再次设置为 0（而之前可能为负值或 undefined）。否则，返回 0 处的属性，其余属性向左移动 1。length 属性递减 1。
```js
const myFish = ["angel", "clown", "mandarin", "surgeon"];
console.log("调用 shift 之前：", myFish);
// 调用 shift 之前： ['angel', 'clown', 'mandarin', 'surgeon']
const shifted = myFish.shift();
console.log("调用 shift 之后：", myFish);
// 调用 shift 之后： ['clown', 'mandarin', 'surgeon']
console.log("被删除的元素：" + shifted);
// "被删除的元素：angel"
//
const arrayLike = {
  length: 3,
  unrelated: "foo",
  2: 4,
};
console.log(Array.prototype.shift.call(arrayLike));
// undefined，因为它是一个空槽
console.log(arrayLike);
// { '1': 4, length: 2, unrelated: 'foo' }
const plainObj = {};
// 这里没有长度属性，所以长度为 0
Array.prototype.shift.call(plainObj);
console.log(plainObj);
// { length: 0 }
```

### `slice(start, end)`: 返回一个新的数组对象，这一对象是一个由 start 和 end 决定的原数组的浅拷贝（包括 start，不包括 end），其中 start 和 end 代表了数组元素的索引。原始数组不会被改变。
- start 可选 提取起始处的索引（从 0 开始），会转换为整数。
  - 如果索引是负数，则从数组末尾开始计算——如果 start < 0，则使用 start + array.length。
  - 如果 start < -array.length 或者省略了 start，则使用 0。
  - 如果 start >= array.length，则不提取任何元素。
- end 可选 提取终止处的索引（从 0 开始），会转换为整数。slice() 会提取到但不包括 end 的位置。
  - 如果索引是负数，则从数组末尾开始计算——如果 end < 0，则使用 end + array.length。
  - 如果 end < -array.length，则使用 0。
  - 如果 end >= array.length 或者省略了 end，则使用 array.length，提取所有元素直到末尾。
  - 如果 end 在规范化后小于或等于 start，则不提取任何元素。
- 返回值 一个含有被提取元素的新数组。
- slice() 方法是一个复制方法。它不会改变 this，而是返回一个浅拷贝，其中包含了原始数组的一部分相同的元素。
- slice() 方法会保留空槽。如果被切片的部分是稀疏的，则返回的数组也是稀疏的。
- slice() 方法是通用的。它只要求 this 上有 length 属性和整数键属性。
```js
// 使用 slice 方法从 myCar 创建一个 newCar。
const myHonda = {
  color: "red",
  wheels: 4,
  engine: { cylinders: 4, size: 2.2 },
};
const myCar = [myHonda, 2, "cherry condition", "purchased 1997"];
const newCar = myCar.slice(0, 2);
console.log("myCar =", myCar);
// myCar = [
//   { color: 'red', wheels: 4, engine: { cylinders: 4, size: 2.2 } },
//   2,
//   'cherry condition',
//   'purchased 1997'
// ]
console.log("newCar =", newCar); // newCar = [ { color: 'red', wheels: 4, engine: { cylinders: 4, size: 2.2 } }, 2 ]
console.log("myCar[0].color =", myCar[0].color); // myCar[0].color = red
console.log("newCar[0].color =", newCar[0].color); // newCar[0].color = red
// 改变 myHonda 对象的 color。
myHonda.color = "purple";
console.log("The new color of my Honda is", myHonda.color); // The new color of my Honda is purple
console.log("myCar[0].color =", myCar[0].color); // myCar[0].color = purple
console.log("newCar[0].color =", newCar[0].color); // newCar[0].color = purple
//
console.log([1, 2, , 4, 5].slice(1, 4)); // [2, empty, 4]
```
- slice() 方法会读取 this 对象的 length 属性，然后从 start 到 end 读取整数键属性，并将它们定义在一个新创建的数组中。
```js
const arrayLike = {
  length: 3,
  0: 2,
  1: 3,
  2: 4,
};
console.log(Array.prototype.slice.call(arrayLike, 1, 3));
// [ 3, 4 ]
```
- slice() 方法经常与 bind() 和 call() 一起使用，用于创建一个实用方法，将类数组对象转换为数组。
```js
// 调用 slice() 方法时，会将 this 对象作为第一个参数传入
const slice = Function.prototype.call.bind(Array.prototype.slice);
function list() {
  return slice(arguments);
}
const list1 = list(1, 2, 3); // [1, 2, 3]
```

### `some(callbackFn, thisArg)`: 测试数组中是否至少有一个元素通过了由提供的函数实现的测试。如果在数组中找到一个元素使得提供的函数返回 true，则返回 true；否则返回 false。它不会修改数组。
- callbackFn 为数组中的每个元素执行的函数。它应该返回一个真值以指示元素通过测试，否则返回一个假值。该函数被调用时将传入以下参数：
  - element 数组中当前正在处理的元素。
  - index 正在处理的元素在数组中的索引。
  - array 调用了 some() 的数组本身。
- thisArg 可选 执行 callbackFn 时用作 this 的值。
- 返回值 如果回调函数对数组中至少一个元素返回一个真值，则返回 true。否则返回 false。
- some() 方法是一个迭代方法。它为数组中的每个元素调用一次指定的 callbackFn 函数，直到 callbackFn 返回一个真值。如果找到这样的元素，some() 方法将会立即返回 true 并停止遍历数组。否则，如果 callbackFn 对所有元素都返回假值，some() 就会返回 false。
- some() 类似于数学中的“存在量词（∃）”。特别地，在对于一个空数组，任何条件下它都返回 false。
- callbackFn 仅针对已分配值的数组索引调用。它不会为稀疏数组中的空槽调用。
- some() 不会改变调用它的数组，但指定的 callbackFn 函数可以。但是请注意，数组的长度是在第一次调用 callbackFn 之前保存的。因此：
  - 当开始调用 some() 时，callbackFn 将不会访问超出数组初始长度的任何元素。
  - 对已访问索引的更改不会导致再次在这些元素上调用 callbackFn。
  - 如果数组中一个现有的、尚未访问的元素被 callbackFn 更改，则它传递给 callbackFn 的值将是该元素被修改后的值。被删除的元素则不会被访问。
- some() 方法是通用的。它只期望 this 值具有 length 属性和整数键属性。
```js
[2, 5, 8, 1, 4].some((x) => x > 10); // false
[12, 5, 8, 1, 4].some((x) => x > 10); // true
// some() 不会在空槽上运行它的断言函数。
console.log([1, , 3].some((x) => x === undefined)); // false
console.log([1, , 1].some((x) => x !== 1)); // false
console.log([1, undefined, 1].some((x) => x !== 1)); // true
// some() 方法读取 this 的 length 属性，然后访问每个整数索引，直到到达末尾或 callbackFn 返回 true。
const arrayLike = {
  length: 3,
  0: "a",
  1: "b",
  2: "c",
};
console.log(Array.prototype.some.call(arrayLike, (x) => typeof x === "number"));
// false
```

### `sort(compareFn)`: 就地对数组的元素进行排序，并返回对相同数组的引用。默认排序是将元素转换为字符串，然后按照它们的 UTF-16 码元值升序排序。
- compareFn 可选 定义排序顺序的函数。返回值应该是一个数字，其正负性表示两个元素的相对顺序。如果省略该函数，数组元素会被转换为字符串，然后根据每个字符的 Unicode 码位值进行排序。该函数使用以下参数调用：
  - a 第一个用于比较的元素。不会是 undefined。
  - b 第二个用于比较的元素。不会是 undefined。
- 返回值 经过排序的原始数组的引用。注意数组是就地排序的，不会进行复制。
- 由于它取决于具体实现，因此无法保证排序的时间和空间复杂度。
- 如果想要不改变原数组的排序方法，可以使用 toSorted()。
- 如果没有提供 compareFn，所有非 undefined 的数组元素都会被转换为字符串，并按照 UTF-16 码元顺序比较字符串进行排序。例如“banana”会被排列到“cherry”之前。在数值排序中，9 出现在 80 之前，但因为数字会被转换为字符串，在 Unicode 顺序中“80”排在“9”之前。所有的 undefined 元素都会被排序到数组的末尾。
  - 在 UTF-16 中，Unicode 字符超出 \uFFFF 的范围会被编码为两个代理码元（surrogate code unit），这些码位的范围是 \uD800 到 \uDFFF。每个码位的值都会被单独考虑进行比较。因此，由代理对 \uD855\uDE51 组成的字符将排在字符 \uFF3A 的前面。
- sort() 方法保留空槽。如果源数组是稀疏的，则空槽会被移动到数组的末尾，并始终排在所有 undefined 元素的后面。
- 如果提供了 compareFn，所有非 undefined 的数组元素都会按照比较函数的返回值进行排序（所有的 undefined 元素都会被排序到数组的末尾，并且不调用 compareFn）。
| compareFn(a, b) 返回值 |    排序顺序             |
|-----------------------|------------------------|
|        > 0	          |   a 在 b 后，如 [b, a]  |
|        < 0	          |   a 在 b 前，如 [a, b]  |
|       === 0	          |   保持 a 和 b 原来的顺序 |
```js
function compareFn(a, b) {
  if (根据排序标准，a 小于 b) {
    return -1;
  }
  if (根据排序标准，a 大于 b) {
    return 1;
  }
  // a 一定等于 b
  return 0;
}
```
- 更正式地说，为了确保正确的排序行为，比较函数应具有以下属性：
  - 纯函数：比较函数不会改变被比较的对象或任何外部状态。（这很重要，因为无法保证比较函数将在何时以及如何调用，因此任何特定的调用都不应对外部产生可见的效果。）
  - 稳定性：比较函数对于相同的输入对应始终返回相同的结果。
  - 自反性：compareFn(a, a) === 0。
  - 反对称性：compareFn(a, b) 和 compareFn(b, a) 必须都是 0 或者具有相反的符号。
  - 传递性：如果 compareFn(a, b) 和 compareFn(b, c) 都是正数、零或负数，则 compareFn(a, c) 的符号与前面两个相同。
- 符合上述限制的比较函数将始终能够返回 1、0 和 -1 中的任意一个，或者始终返回 0。例如，如果比较函数只返回 1 和 0，或者只返回 0 和 -1，它将无法可靠地排序，因为反对称性被破坏了。一个总是返回 0 的比较函数将不会改变数组，但仍然是可靠的。
- 默认的字典比较函数符合上述所有限制。
- 要比较数字而非字符串，比较函数可以简单的用 a 减 b，如下的函数将会将数组升序排列（如果它不包含 Infinity 和 NaN）：
```js
function compareNumbers(a, b) {
  return a - b;
}
```
- sort() 方法是通用的，它只期望 this 值具有 length 属性和整数键属性。虽然字符串也类似于数组，但此方法不适用于字符串，因为字符串是不可变的。
```js
const stringArray = ["Blue", "Humpback", "Beluga"];
const numberArray = [40, 1, 5, 200];
const numericStringArray = ["80", "9", "700"];
const mixedNumericArray = ["80", "9", "700", 40, 1, 5, 200];
function compareNumbers(a, b) {
  return a - b;
}
stringArray.join(); // 'Blue,Humpback,Beluga'
stringArray.sort(); // ['Beluga', 'Blue', 'Humpback']
numberArray.join(); // '40,1,5,200'
numberArray.sort(); // [1, 200, 40, 5]
numberArray.sort(compareNumbers); // [1, 5, 40, 200]
numericStringArray.join(); // '80,9,700'
numericStringArray.sort(); // ['700', '80', '9']
numericStringArray.sort(compareNumbers); // ['9', '80', '700']
mixedNumericArray.join(); // '80,9,700,40,1,5,200'
mixedNumericArray.sort(); // [1, 200, 40, 5, '700', '80', '9']
mixedNumericArray.sort(compareNumbers); // [1, 5, '9', 40, '80', 200, '700']
```
```js
const items = [
  { name: "Edward", value: 21 },
  { name: "Sharpe", value: 37 },
  { name: "And", value: 45 },
  { name: "The", value: -12 },
  { name: "Magnetic", value: 13 },
  { name: "Zeros", value: 37 },
];
// 根据 value 排序
items.sort((a, b) => a.value - b.value);
// 根据 name 排序
items.sort((a, b) => {
  const nameA = a.name.toUpperCase(); // 忽略大小写
  const nameB = b.name.toUpperCase(); // 忽略大小写
  if (nameA < nameB) {
    return -1;
  }
  if (nameA > nameB) {
    return 1;
  }
  // name 必须相等
  return 0;
});
```
- 当排序非 ASCII 字符的字符串（如包含类似 e、é、è、a、ä 等字符的字符串）。一些非英语语言的字符串需要使用 String.localeCompare。这个函数可以将函数排序到正确的顺序。
```js
var items = ["réservé", "premier", "cliché", "communiqué", "café", "adieu"];
items.sort(function (a, b) {
  return a.localeCompare(b);
});
// items 是 ['adieu', 'café', 'cliché', 'communiqué', 'premier', 'réservé']
```
- compareFn 可能会在数组中的每个元素上调用多次。根据 compareFn 的性质，这可能会产生很高的开销。如果 compareFn 执行的工作更多，需要排序的元素更多，使用 map() 进行排序可能更有效率。其思路是遍历数组一次，将用于排序的实际值提取到一个临时数组中，对临时数组进行排序，然后遍历临时数组以获得正确的顺序。
```js
// 需要被排序的数组
const data = ["delta", "alpha", "charlie", "bravo"];
// 用于存放位置和排序值的对象数组
const mapped = data.map((v, i) => {
  return { i, value: someSlowOperation(v) };
});
// 按照多个值排序数组
mapped.sort((a, b) => {
  if (a.value > b.value) {
    return 1;
  }
  if (a.value < b.value) {
    return -1;
  }
  return 0;
});
const result = mapped.map((v) => data[v.i]);
```
- sort() 方法返回对原始数组的引用，因此更改返回的数组将同时更改原始数组。
```js
const numbers = [3, 1, 4, 1, 5];
const sorted = numbers.sort((a, b) => a - b);
// numbers 和 sorted 都是 [1, 1, 3, 4, 5]
sorted[0] = 10;
console.log(numbers[0]); // 10
```
- 自 EcmaScript 第 10 版（EcmaScript 2019）起，规范 要求 Array.prototype.sort 为稳定排序。
```js
// 假设有一个包含学生名字和年级的列表，已经将它按学生名字字母顺序进行预排序：
const students = [
  { name: "Alex", grade: 15 },
  { name: "Devlin", grade: 15 },
  { name: "Eagle", grade: 13 },
  { name: "Sam", grade: 14 },
];
// 对这个数组执行 grade 升序排序后：
students.sort((firstItem, secondItem) => firstItem.grade - secondItem.grade);
// students 变量会具有以下值：
[
  { name: "Eagle", grade: 13 },
  { name: "Sam", grade: 14 },
  { name: "Alex", grade: 15 }, // grade 相同时维持原先的顺序（稳定排序）
  { name: "Devlin", grade: 15 }, // grade 相同时维持原先的顺序（稳定排序）
];
// 注意，那些年级相同的学生（如 Alex 和 Devlin）会维持调用排序之前的顺序，这是稳定排序所确保的。
// EcmaScript 第 10 版（EcmaScript 2019）以前没有要求稳定性，意味着你可能会得到以下结果：
[
  { name: "Eagle", grade: 13 },
  { name: "Sam", grade: 14 },
  { name: "Devlin", grade: 15 }, // 没有维持原先的顺序
  { name: "Alex", grade: 15 }, // 没有维持原先的顺序
];
```
- 如果一个比较函数不符合纯函数、稳定性、自反性、反对称性和传递性规则，就像在描述中解释的那样，程序的行为是未定义的。
```js
const arr = [3, 1, 4, 1, 5, 9];
const compareFn = (a, b) => (a > b ? 1 : 0);
arr.sort(compareFn);
// 在这个例子中，compareFn 函数是不规范的，因为它不满足反对称性：如果 a > b，它返回 1；但是通过交换 a 和 b，它返回了 0 而不是一个负值。因此，对于不同的引擎，结果数组也会有所不同。例如，V8（用于 Chrome、Node.js 等）和 JavaScriptCore（用于 Safari）根本不会对数组进行排序，而是返回 [3, 1, 4, 1, 5, 9]；而 SpiderMonkey（用于 Firefox）将返回升序排序的数组 [1, 1, 3, 4, 5, 9]。
// 
// 如果 compareFn 函数稍微改变一下，使其返回 -1 或 0：
const arr = [3, 1, 4, 1, 5, 9];
const compareFn = (a, b) => (a > b ? -1 : 0);
arr.sort(compareFn);
// 那么在 V8 和 JavaScriptCore 中，它将按降序排序，结果为 [9, 5, 4, 3, 1, 1]，而 SpiderMonkey 返回的结果是原始数组：[3, 1, 4, 1, 5, 9]。
// 由于这种实现的不一致性，建议始终遵循五个约束条件以确保你的比较函数是规范的。
```
- 在稀疏数组上使用 sort()，空槽会被移动到数组的末尾。
```js
console.log(["a", "c", , "b"].sort()); // ['a', 'b', 'c', empty]
console.log([, undefined, "a", "b"].sort()); // ["a", "b", undefined, empty]
```
- sort() 方法会读取 this 的 length 属性。然后它会收集在 0 到 length - 1 范围内所有已存在的整数键属性，对它们进行排序，然后写回。如果范围内存在缺失的属性，则相应的尾随属性将被删除，好像不存在的属性被排序到末尾一样。
```js
const arrayLike = {
  length: 3,
  unrelated: "foo",
  0: 5,
  2: 4,
};
console.log(Array.prototype.sort.call(arrayLike));
// { '0': 4, '1': 5, length: 3, unrelated: 'foo' }
```

### `splice(start, deleteCount, item1, item2, itemN)`: 通过移除或者替换已存在的元素(和/或)添加新元素就地改变一个数组的内容。要创建一个删除(和/或)替换部分内容而不改变原数组的新数组，请使用 toSpliced()。要访问数组的一部分而不修改它，使用 slice()。
- start 从 0 开始计算的索引，表示要开始改变数组的位置，它会被转换成整数。
  - 负索引从数组末尾开始计算——如果 start < 0，使用 start + array.length。
  - 如果 start < -array.length，使用 0。
  - 如果 start >= array.length，则不会删除任何元素，但是该方法会表现为添加元素的函数，添加所提供的那些元素。
  - 如果 start 被省略了（即调用 splice() 时不传递参数），则不会删除任何元素。这与传递 undefined 不同，后者会被转换为 0。
- deleteCount 可选 一个整数，表示数组中要从 start 开始删除的元素数量。
  - 如果省略了 deleteCount，或者其值大于或等于由 start 指定的位置到数组末尾的元素数量，那么从 start 到数组末尾的所有元素将被删除。但是，如果你想要传递任何 itemN 参数，则应向 deleteCount 传递 Infinity 值，以删除 start 之后的所有元素，因为显式的 undefined 会转换为 0。
  - 如果 deleteCount 是 0 或者负数，则不会移除任何元素。在这种情况下，你应该至少指定一个新元素。
- item1, …, itemN 可选 从 start 开始要加入到数组中的元素。
  - 如果不指定任何元素，splice() 将只从数组中删除元素。
- 返回值 一个包含了删除的元素的数组。
  - 如果只移除一个元素，则返回一个元素的数组。
  - 如果没有删除任何元素，则返回一个空数组。
- splice() 方法是一个修改方法。它可能会更改 this 的内容。如果指定的要插入的元素数量与要删除的元素数量不同，数组的 length 也将会更改。同时，它会使用 @@species 来创建一个新数组实例并返回。
- 如果删除的部分是稀疏的，则 splice() 返回的数组也是稀疏的，对应的索引为空槽。
- splice() 方法是通用的。它只期望 this 值具有 length 属性和整数键属性。尽管字符串也类似于数组，但这种方法不适用于它，因为字符串是不可变的。
```js
// 移除索引 2 之前的 0（零）个元素，并插入“drum”
const myFish = ["angel", "clown", "mandarin", "sturgeon"];
const removed = myFish.splice(2, 0, "drum");
// 运算后的 myFish 是 ["angel", "clown", "drum", "mandarin", "sturgeon"]
// removed 是 []，没有元素被删除
// 
// 移除索引 2 之前的 0（零）个元素，并插入“drum”和“guitar”
const myFish = ["angel", "clown", "mandarin", "sturgeon"];
const removed = myFish.splice(2, 0, "drum", "guitar");
// 运算后的 myFish 是 ["angel", "clown", "drum", "guitar", "mandarin", "sturgeon"]
// removed 是 []，没有元素被删除
//
// 在索引 3 处移除 1 个元素
const myFish = ["angel", "clown", "drum", "mandarin", "sturgeon"];
const removed = myFish.splice(3, 1);
// 运算后的 myFish 是 ["angel", "clown", "drum", "sturgeon"]
// removed 是 ["mandarin"]
//
// 在索引 2 处移除 1 个元素，并插入“trumpet”
const myFish = ["angel", "clown", "drum", "sturgeon"];
const removed = myFish.splice(2, 1, "trumpet");
// 运算后的 myFish 是 ["angel", "clown", "trumpet", "sturgeon"]
// removed 是 ["drum"]
//
// 从索引 0 处移除 2 个元素，并插入“parrot”、“anemone”和“blue”
const myFish = ["angel", "clown", "trumpet", "sturgeon"];
const removed = myFish.splice(0, 2, "parrot", "anemone", "blue");
// 运算后的 myFish 是 ["parrot", "anemone", "blue", "trumpet", "sturgeon"]
// removed 是 ["angel", "clown"]
//
// 从索引 -2 处移除 1 个元素
const myFish = ["angel", "clown", "mandarin", "sturgeon"];
const removed = myFish.splice(-2, 1);
// 运算后的 myFish 是 ["angel", "clown", "sturgeon"]
// removed 是 ["mandarin"]
//
// 从索引 2 开始删除所有元素
const myFish = ["angel", "clown", "mandarin", "sturgeon"];
const removed = myFish.splice(2);
// 运算后的 myFish 是 ["angel", "clown"]
// removed 是 ["mandarin", "sturgeon"]
```
- splice() 方法保留了数组的稀疏性。
```js
const arr = [1, , 3, 4, , 6];
console.log(arr.splice(1, 2)); // [empty, 3]
console.log(arr); // [1, 4, empty, 6]
```
- splice() 方法读取 this 的 length 属性。然后，它根据需要更新整数键属性和 length 属性。
```js
const arrayLike = {
  length: 3,
  unrelated: "foo",
  0: 5,
  2: 4,
};
console.log(Array.prototype.splice.call(arrayLike, 0, 1, 2, 3)); // [ 5 ]
console.log(arrayLike); // { '0': 2, '1': 3, '3': 4, length: 4, unrelated: 'foo' }
```

### `toLocaleString(locales, options)`: 返回一个字符串，表示数组中的所有元素。每个元素通过调用它们自己的 toLocaleString 方法转换为字符串，并且使用特定于语言环境的字符串（例如逗号“,”）分隔开。
- locales 可选 带有 BCP 47 语言标签的字符串，或者此类字符串的数组。对于 locales 参数的一般形式和说明，可以参见 Intl 主页面的参数说明。
- options 可选 一个具有配置属性的对象。对于数字，请参见 Number.prototype.toLocaleString()；对于日期，请参见 Date.prototype.toLocaleString()。
- 返回值 一个字符串，表示数组中的所有元素。
- Array.prototype.toLocaleString 方法遍历数组内容，并使用提供的 locales 和 options 参数调用每个元素的 toLocaleString 方法，通过由实现定义的分隔符（例如逗号“,”）将转换后的字符串拼接起来。请注意，该方法本身不会使用这两个参数——它只是将其传递给每个元素的 toLocaleString()。分隔符的选择取决于主机当前的语言环境，而不是 locales 参数。
- 如果一个元素是 undefined、null，它会被转换为空字符串，而不是 "null" 或者 "undefined"。
- 当用于稀疏数组时，toLocaleString() 方法迭代时会把空槽当作 undefined 一样处理它。
- toLocaleString() 方法是通用的。它只期望 this 值具有 length 属性和整数键属性。
```js
// 使用 locales 和 options
// 数组元素通过使用它们的 toLocaleString 方法转换为字符串。
// Object：Object.prototype.toLocaleString()
// Number：Number.prototype.toLocaleString()
// Date：Date.prototype.toLocaleString()
// 始终显示 prices 数组中字符串和数字的货币符号：
const prices = ["￥7", 500, 8123, 12];
prices.toLocaleString("ja-JP", { style: "currency", currency: "JPY" });
// "￥7,￥500,￥8,123,￥12"
//
// toLocaleString() 将空槽视为 undefined ，并生成一个额外的分隔符：
console.log([1, , 3].toLocaleString()); // '1,,3'
//
// toLocaleString() 方法读取 this 的 length 属性，然后访问每个整数索引。
const arrayLike = {
  length: 3,
  0: 1,
  1: 2,
  2: 3,
};
console.log(Array.prototype.toLocaleString.call(arrayLike));
// 1,2,3
```

### `toReversed()`: 是 reverse() 方法对应的复制版本。它返回一个元素顺序相反的新数组。
- 返回值 一个包含以相反顺序排列元素的新数组。
- toReversed() 方法将调用该方法的数组对象的元素以相反的顺序调换，并返回一个新数组。
- 当用于稀疏数组时，toReversed() 方法迭代空槽，就像它们的值是 undefined 一样。
  - toReversed() 的返回值永远不是稀疏的。空槽在返回的数组中变为 undefined。
- toReversed() 方法是通用的。它只期望 this 值具有 length 属性和整数键属性。
  - toReversed() 方法读取 this 的 length 属性。然后按降序访问 length - 1 和 0 之间的每个索引，并将原始数组中该索引的值添加到新数组相应的索引中。
```js
const items = [1, 2, 3];
console.log(items); // [1, 2, 3]
const reversedItems = items.toReversed();
console.log(reversedItems); // [3, 2, 1]
console.log(items); // [1, 2, 3]
// toReversed() 的返回值永远不是稀疏的。空槽在返回的数组中变为 undefined。
console.log([1, , 3].toReversed()); // [3, undefined, 1]
console.log([1, , 3, 4].toReversed()); // [4, 3, undefined, 1]
//
// toReversed() 方法读取 this 的 length 属性。然后按降序访问 length - 1 和 0 之间的每个索引，并将原始数组中该索引的值添加到新数组相应的索引中。
const arrayLike = {
  length: 3,
  unrelated: "foo",
  2: 4,
};
console.log(Array.prototype.toReversed.call(arrayLike));
// [4, undefined, undefined]
// '0' 和 '1' 两个索引不存在，所以它们会变成 undefined
```

### `toSorted(compareFn)`: 是 sort() 方法的复制方法版本。它返回一个新数组，其元素按升序排列。
- compareFn 可选 指定一个定义排序顺序的函数。如果省略，则将数组元素转换为字符串，然后根据每个字符的 Unicode 码位值进行排序。
  - a 用于比较的第一个元素。
  - b 用于比较的第二个元素。
  - 有关 compareFn 参数的更多信息，请参阅 sort()。
- 返回值 一个新数组，其元素按升序排序。
- 当在稀疏数组上使用 toSorted() 方法时，它迭代时会将空槽视为具有 undefined 值的元素。
  - 空槽被视为具有 undefined 值而被排序。它们总是排序到数组的末尾，并且 compareFn 不会对它们进行调用。
- toSorted() 方法是通用的，它只期望 this 值具有 length 属性和整数键属性。
```js
const months = ["Mar", "Jan", "Feb", "Dec"];
const sortedMonths = months.toSorted();
console.log(sortedMonths); // ['Dec', 'Feb', 'Jan', 'Mar']
console.log(months); // ['Mar', 'Jan', 'Feb', 'Dec']
const values = [1, 10, 21, 2];
const sortedValues = values.toSorted((a, b) => a - b);
console.log(sortedValues); // [1, 2, 10, 21]
console.log(values); // [1, 10, 21, 2]
```
```js
// 空槽被视为具有 undefined 值而被排序。它们总是排序到数组的末尾，并且 compareFn 不会对它们进行调用。
console.log(["a", "c", , "b"].toSorted()); // ['a', 'b', 'c', undefined]
console.log([, undefined, "a", "b"].toSorted()); // ["a", "b", undefined, undefined]
const arrayLike = {
  length: 3,
  unrelated: "foo",
  0: 5,
  2: 4,
};
console.log(Array.prototype.toSorted.call(arrayLike));
// [4, 5, undefined]
```

### `toSpliced(start, deleteCount, item1, item2, itemN)`: 是 splice() 方法的复制版本。它返回一个新数组，并在给定的索引处删除和/或替换了一些元素。
- start 从 0 开始计算的索引，表示要开始改变数组的位置，它会被转换为整数。
  - 如果 start < 0，则从数组末尾开始计数，使用 start + array.length。
  - 如果 start < -array.length 或者省略了 start，则使用 0。
  - 如果 start >= array.length，不会删除任何元素，但该方法将表现为添加元素的函数，添加提供的所有元素。
- deleteCount 可选 一个整数，指示数组中要从 start 删除的元素数量。
- 如果 deleteCount 被省略了，或者如果它的值大于或等于由 start 指定的位置到数组末尾的元素数量，将会删除从 start 到数组末尾的所有元素。但是，如果你想要传递任何 itemN 参数，则应向 deleteCount 传递 Infinity 值，以删除 start 之后的所有元素，因为显式的 undefined 会转换为 0。
- 如果 deleteCount 是 0 或者负数，则不会删除元素。在这种情况下，你应该指定至少一个新元素（见下文）。
- item1, …, itemN 可选 元素将从 start 开始添加到数组当中。
  - 如果你没有指定任何元素，toSpliced() 只会从数组中删除元素。
- 返回值 一个新数组，由 start 之前的所有元素、item1、item2、...、itemN，以及 start + deleteCount 之后的所有元素组成。
- toSpliced() 方法与 splice() 类似，可以同时完成多个操作：在数组中给定的索引开始移除指定数量的元素，然后在相同的索引处插入给定的元素。但是，它返回一个新数组，而不是修改原始数组。因此，此方法不会返回已删除的元素。
- toSpliced() 方法不会产生稀疏数组。如果原始数组是稀疏的，在新数组中空槽将会被替换成 undefined。
- toSpliced() 方法是通用的。它只期望 this 值具有 length 属性和整数键属性。
```js
const months = ["Jan", "Mar", "Apr", "May"];
// 在索引 1 处添加一个元素
const months2 = months.toSpliced(1, 0, "Feb");
console.log(months2); // ["Jan", "Feb", "Mar", "Apr", "May"]
// 从第 2 个索引开始删除两个元素
const months3 = months2.toSpliced(2, 2);
console.log(months3); // ["Jan", "Feb", "May"]
// 在索引 1 处用两个新元素替换一个元素
const months4 = months3.toSpliced(1, 1, "Feb", "Mar");
console.log(months4); // ["Jan", "Feb", "Mar", "May"]
// 原数组不会被修改
console.log(months); // ["Jan", "Mar", "Apr", "May"]
const arr = [1, , 3, 4, , 6];
console.log(arr.toSpliced(1, 2)); // [1, 4, undefined, 6]
const arrayLike = {
  length: 3,
  unrelated: "foo",
  0: 5,
  2: 4,
};
console.log(Array.prototype.toSpliced.call(arrayLike, 0, 1, 2, 3));
// [2, 3, undefined, 4]
```

### `toString()`: 返回一个表示调用数组及其元素的字符串。重写 Object.prototype.toString() 方法。
- 返回值 一个表示数组元素的字符串。
- Array 对象覆盖了 Object 的 toString 方法。数组的 toString 方法实际上在内部调用了 join() 方法来拼接数组并返回一个包含所有数组元素的字符串，元素之间用逗号分隔。如果 join 方法不可用或者不是函数，则会使用 Object.prototype.toString 来代替，并返回 [object Array]。
```js
const arr = [];
arr.join = 1; // 将 `join` 重新赋值为非函数的值
console.log(arr.toString()); // [object Array]
console.log(Array.prototype.toString.call({ join: () => 1 })); // 1
```
- 当数组需要被表示为文本值，或者当数组在字符串拼接中被引用时，JavaScript 会自动调用 toString() 方法。
- 与 join() 的行为一致，toString() 将空槽视为 undefined 并生成一个额外的分隔符：
```js
const array1 = [1, 2, "a", "1a"];
console.log(array1.toString()); // "1,2,a,1a"
console.log([1, , 3].toString()); // '1,,3'
// toString() 是通用的。它期望 this 具有 join() 方法；如果不存在，则使用 Object.prototype.toString()。
console.log(Array.prototype.toString.call({ join: () => 1 }));
// 1; 一个数字
console.log(Array.prototype.toString.call({ join: () => undefined }));
// undefined
console.log(Array.prototype.toString.call({ join: "not function" }));
// "[object Object]"
```

### `unshift(element1, element2, /* …, */ elementN)`: 将指定元素添加到数组的开头，并返回数组的新长度。
- element1、…、elementN 添加到 arr 开头的元素。
- 返回值 返回调用方法对象的新 length 属性。
- unshift() 方法将给定的值插入到类数组对象的开头。
- Array.prototype.push() 有着和 unshift() 相似的行为，但是其将元素插入到数组的末尾。
- 请注意，如果多个元素作为参数传递，它们将被插入到对象开头的块中，与它们作为参数传递的顺序完全相同。因此，调用一次 unshift() 方法并传递 n 个参数，与调用 n 次并传递 1 个参数（例如使用循环），不会产生相同的结果。
- unshift() 方法是通用的。它只期望 this 值具有 length 属性和整数键属性。虽然字符串也是类似于数组的，但这个方法不适用于它们，因为字符串是不可变的。
  - unshift 方法会读取 this 的 length 属性。然后，它将 0 到 length - 1 范围内的所有属性按参数数量右移，并将每个索引从 0 开始，并将参数传递给 unshift()。最后，它将 length 设置为之前的长度加上前置元素的数量。
```js
const arr = [1, 2];
arr.unshift(0); // 调用的结果是 3，这是新的数组长度。
// 数组是 [0, 1, 2]
arr.unshift(-2, -1); // 新的数组长度是 5
// 数组是 [-2, -1, 0, 1, 2]
arr.unshift([-4, -3]); // 新的数组长度是 6
// 数组是 [[-4, -3], -2, -1, 0, 1, 2]
arr.unshift([-7, -6], [-5]); // 新的数组长度是 8
// 数组是 [ [-7, -6], [-5], [-4, -3], -2, -1, 0, 1, 2 ]
```
```js
const arrayLike = {
  length: 3,
  unrelated: "foo",
  2: 4,
};
Array.prototype.unshift.call(arrayLike, 1, 2);
console.log(arrayLike);
// { '0': 1, '1': 2, '4': 4, length: 5, unrelated: 'foo' }
const plainObj = {};
// 这里没有长度属性，所以这里的长的为 0
Array.prototype.unshift.call(plainObj, 1, 2);
console.log(plainObj);
// { '0': 1, '1': 2, length: 2 }
```

### `values()`: 返回一个新的数组迭代器对象，该对象包含数组中每个索引的值。
- 返回值 一个新的可迭代迭代器对象。
- Array.prototype.values() 是 Array.prototype[@@iterator]() 的默认实现。
  - `Array.prototype.values === Array.prototype[Symbol.iterator]; // true`
- 当应用于稀疏数组时，values() 方法会将空槽作为 undefined 迭代。
- values() 方法是通用的。它只需要 this 值具有 length 属性和整数键属性。
```js
// 由于 values() 返回一个可迭代迭代器对象，你可以使用 for...of 循环来迭代它。
const arr = ["a", "b", "c", "d", "e"];
const iterator = arr.values();
for (const letter of iterator) {
  console.log(letter);
} // "a" "b" "c" "d" "e"
//
// 由于返回值也是一个迭代器，你可以直接调用其 next() 方法。
const arr = ["a", "b", "c", "d", "e"];
const iterator = arr.values();
iterator.next(); // { value: "a", done: false }
iterator.next(); // { value: "b", done: false }
iterator.next(); // { value: "c", done: false }
iterator.next(); // { value: "d", done: false }
iterator.next(); // { value: "e", done: false }
iterator.next(); // { value: undefined, done: true }
console.log(iterator.next().value); // undefined
//
// values() 返回的可迭代对象是不可重复使用的。当 next().done = true 或 currentIndex > length 时，for...of 循环结束，进一步迭代它没有任何效果。
const arr = ["a", "b", "c", "d", "e"];
const values = arr.values();
for (const letter of values) {
  console.log(letter);
}
// "a" "b" "c" "d" "e"
for (const letter of values) {
  console.log(letter);
}
// undefined
//
// 如果使用 break 语句提前结束迭代，当继续迭代时，迭代器可以从当前位置恢复迭代。
const arr = ["a", "b", "c", "d", "e"];
const values = arr.values();
for (const letter of values) {
  console.log(letter);
  if (letter === "b") {
    break;
  }
}
// "a" "b"
for (const letter of values) {
  console.log(letter);
}
// "c" "d" "e"
//
// values() 返回的数组迭代器对象中没有存储任何值；但是它存储了用于创建它的数组的地址，并在每次迭代中读取当前访问的索引。因此，它的迭代输出取决于在迭代时存储在该索引中的值。如果数组中的值发生了改变，数组迭代器对象的值也会改变。
const arr = ["a", "b", "c", "d", "e"];
const iterator = arr.values();
console.log(iterator); // Array Iterator { }
console.log(iterator.next().value); // "a"
arr[1] = "n";
console.log(iterator.next().value); // "n"
```
```js
// values() 会访问空槽并将其视为 undefined。
for (const element of [, "a"].values()) {
  console.log(element);
}
// undefined
// 'a'
// 
// values() 方法读取 this 的 length 属性，然后访问每个整数索引。
const arrayLike = {
  length: 3,
  0: "a",
  1: "b",
  2: "c",
};
for (const entry of Array.prototype.values.call(arrayLike)) {
  console.log(entry);
}
// a
// b
// c
```

### `with(index, value)`: 是使用方括号表示法修改指定索引值的复制方法版本。它会返回一个新数组，其指定索引处的值会被新值替换。
- index 要修改的数组索引（从 0 开始），将会转换为整数。
  - 负数索引会从数组末尾开始计数——即当 index < 0 时，会使用 index + array.length。
  - 如果规范化后的索引超出数组边界，会抛出 RangeError。
- value 要分配给指定索引的任何值。
- 返回值 一个全新的数组，其中 index 索引处的元素被替换为 value。
- 异常 RangeError index > array.length 或 index < -array.length 时抛出。
- with() 通过返回一个指定索引处的值被新值替换的新数组，来改变数组中指定索引处的值。原数组不会被修改。这使得你可以以链式调用数组方法的方式来对数组进行操作。
- with() 方法永远不会产生稀疏数组。如果原数组是稀疏的，新数组对应的空白索引位置会替换为 undefined。
- with() 方法是通用的。它只期望 this 值具有 length 属性和整数键属性。
```js
const arr = [1, 2, 3, 4, 5];
console.log(arr.with(2, 6)); // [1, 2, 6, 4, 5]
console.log(arr); // [1, 2, 3, 4, 5]
const arr = [1, 2, 3, 4, 5];
console.log(arr.with(2, 6).map((x) => x ** 2)); // [1, 4, 36, 16, 25]
const arr = [1, , 3, 4, , 6];
console.log(arr.with(0, 2)); // [2, undefined, 3, 4, undefined, 6]
//
// with() 方法会读取 this 上的 length 属性，之后读取 this 上的每个整数键并写入到新数组中，同时 value 会被写入指定的 index。
const arrayLike = {
  length: 3,
  unrelated: "foo",
  0: 5,
  2: 4,
};
console.log(Array.prototype.with.call(arrayLike, 0, 1));
// [ 1, undefined, 4 ]
```

### `prototype[@@iterator]()`: Array.prototype 的 @@unscopables 数据属性被所有 Array 实例共享。它包含在 ES2015 版本之前 ECMAScript 标准中未收纳的属性名，并且这些属性被排除在由 with 语句绑定的环境中。
- Array 实例的 `[@@iterator]()` 方法实现了迭代协议，允许数组被大多数期望可迭代对象的语法所使用，例如展开语法和 `for...of` 循环。它返回一个数组迭代器对象，该对象会产生数组中每个索引的值。该属性的初始值与 Array.prototype.values 属性的初始值是相同的函数对象。
- 在 with 语句绑定中未包含的 Array 默认属性包括：
  - at()
  - copyWithin()
  - entries()
  - fill()
  - find()
  - findIndex()
  - findLast()
  - findLastIndex()
  - flat()
  - flatMap()
  - includes()
  - keys()
  - toReversed()
  - toSorted()
  - toSpliced()
  - values()
- Array.prototype[@@unscopables] 是一个只包含所有上述属性且对应值为 true 的空对象。它的原型是 null，因此不会意外地使 Object.prototype 属性（比如 toString）变为非作用域属性，而令在 with 语句中调用数组的 toString() 方法仍然有效。
- 假设下面的 keys.push('something') 是在 ECMAScript 2015 之前编写的代码中调用的。
```js
var keys = [];
with (Array.prototype) {
  keys.push("something");
}
```
- 当 ECMAScript 2015 引入 Array.prototype.keys() 方法时，如果 @@unscopables 数据属性也没有被引入，那么 keys.push('something') 调用将会出现问题——因为 JavaScript 运行时会将 keys 解释为 Array.prototype.keys() 方法，而不是示例代码中定义的 keys 数组。
- 因此，Array.prototype 的 @@unscopables 数据属性使得 ECMAScript 2015 中引入的 Array 属性在 with 语句绑定时被忽略，从而使得在 ECMAScript 2015 之前编写的代码继续按预期工作，而不会出现问题。
```js
const arr = ["a", "b", "c"];
const letterResult = document.getElementById("letterResult");
for (const letter of arr) {
    const li = document.createElement("li");
    li.textContent = letter;
    letterResult.appendChild(li);
}
// a
// b
// c
// 手动执行
const arr = ["a", "b", "c", "d", "e"];
const arrIter = arr[Symbol.iterator]();
console.log(arrIter.next().value); // a
console.log(arrIter.next().value); // b
console.log(arrIter.next().value); // c
console.log(arrIter.next().value); // d
console.log(arrIter.next().value); // e
```
- 因为字符串和数组都实现了可迭代协议，所以可以设计一个通用函数以相同的方式处理这两种输入。这比直接调用 Array.prototype.values() 更好，后者要求输入是一个数组，或者至少是一个具有这种方法的对象。
```js
function logIterable(it) {
    if (typeof it[Symbol.iterator] !== "function") {
        console.log(it, "不可迭代。");
        return;
    }
    for (const letter of it) {
        console.log(letter);
    }
}
// 数组
logIterable(["a", "b", "c"]);
// a
// b
// c
// 字符串
logIterable("abc");
// a
// b
// c
// 数值
logIterable(123);
// 123 不可迭代。
```

