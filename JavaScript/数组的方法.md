## 构造函数

#### `Array()`: 创建一个新的 Array 对象。

!> 调用 `Array()` 时可以使用或不使用 new。两者都会创建一个新的 Array 实例。

- Array 构造函数会根据给定的元素创建一个 JavaScript 数组，但是当仅有一个参数且为数字时除外。注意，后者仅适用于用 Array 构造函数创建数组，而不适用于用方括号创建的数组字面量。

- 如果传递给 Array 构造函数的唯一参数是介于 0 到 232 - 1（含）之间的整数，这将返回一个新的 JavaScript 数组，其 length 属性设置为该数字（注意：这意味着一个由 arrayLength 个空槽组成的数组，而不是具有实际 undefined 值的槽——参见稀疏数组）。

```js
new Array()
new Array(1) // [empty] 创建一个长度为 1 的空数组
new Array('1') // ['1'] 创建一个长度为 1 的数组，且第一个元素为 '1'
new Array(1, 2) // [1, 2] 创建一个长度为 2 的数组，且第一个元素为 1，第二个元素为 2
new Array(1, 2, /* … ,*/ 999)
new Array(arrayLength) // 至输入一个数字会创建该数字长度的空数组，输入其他内容会以该内容创建数组

Array()
Array(1)
Array(1, 2)
Array(1, 2, /* … ,*/ 999)
Array(arrayLength)
```

## 静态方法

#### 1. `Array.from()`: 从数组类对象或可迭代对象创建一个新的 Array 实例。
   
#### 2. `Array.fromAsync() `: 从异步可迭代、可迭代或类数组对象创建新的 Array 实例。
   
#### 3. `Array.isArray()`: 如果参数是数组则返回 true ，否则返回 false。
   
#### 4. `Array.of()`: 创建一个新的 Array 实例，具有可变数量的参数，而不管参数的数量或类型


## 实例属性

- 以下属性在 Array.prototype 上定义，并由所有 Array 实例共享。
   
   1. `Array.prototype.constructor`: 创建实例对象的构造函数。对于 Array 实例，初始值是 Array 构造函数。
   
   2. `Array.prototype[@@unscopables]`: Array.prototype 的 @@unscopables 数据属性被所有 Array 实例共享。它包含在 ES2015 版本之前 ECMAScript 标准中未收纳的属性名，并且这些属性被排除在由 with 语句绑定的环境中。
   
- 以下属性是每个 Array 实例自有的属性。
   
   1. `Array.prototype.length`: length 是 Array 的实例属性，表示该数组中元素的个数。该值是一个无符号 32 位整数，并且其数值总是大于数组最大索引。


## 实例方法

#### 1. `Array.prototype.at(index)`: 接收一个整数值并返回该索引对应的元素，允许正数和负数。负整数从数组中的最后一个元素开始倒数。如果 `index < -array.length` 或 `index >= array.length`，则总是返回 `undefined`，而不会尝试访问相应的属性。
- at() 方法是通用的。其仅期望 this 具有 length 属性和以整数为键的属性。

```js
const array1 = [5, 12, 8, 130, 44];
let index = 2;
console.log(`An index of ${index} returns ${array1.at(index)}`);
// Expected output: "An index of 2 returns 8"
index = -2;
console.log(`An index of ${index} returns ${array1.at(index)}`);
// Expected output: "An index of -2 returns 130"
```

#### 2. `Array.prototype.concat(value0, value1, /* … ,*/ valueN)`: 用于合并两个或多个数组。此方法**不会更改现有数组**，而是返回一个新数组。
- concat 方法创建一个新数组。该数组将首先由调用它的对象中的元素填充。然后，对于每个参数，它的值将被连接到数组中——对于普通对象或基元，参数本身将成为最终数组的一个元素；对于属性Symbol.isConcatSpreadable设置为真的数组或类数组对象，参数的每个元素都将是独立地添加到最终数组中。concat 方法不会递归到嵌套数组参数中。
- concat() 方法是通用的。this 值的处理方式与其他参数相同（除了它会先转换为对象），这意味着普通对象将直接添加到结果数组中，而 @@isConcatSpreadable 属性为真值的类数组对象将展开并添加到数组中。
- concat() 方法是一种复制方法。它不会更改 this 或作为参数提供的任何数组，而是返回包含与原始数组中的元素相同的元素的浅拷贝。
- 如果任何源数组是稀疏数组，concat() 方法会保留空槽。

```js
const array1 = ['a', 'b', 'c'];
const array2 = ['d', 'e', 'f'];
const array3 = array1.concat(array2);
console.log(array3);
// Expected output: Array ["a", "b", "c", "d", "e", "f"]
```

#### 3. `Array.prototype.copyWithin(target, start, end)`: 浅复制数组的一部分到同一数组中的另一个位置并替换另一位置的元素值，并返回它，不会改变原数组的长度，但**会改变原数组**。
- copyWithin() 方法的工作原理类似于 C 和 C++ 的 memmove，是一种移动数组数据的高性能方法，与 TypedArray 的同名方法类似。序列在一次中操作被复制和粘贴；即使复制和粘贴区域重叠，粘贴的序列也将具有复制值。
- copyWithin() 是修改方法。它不会改变 this 指向的对象（数组或类数组）的长度，但会更改其的内容，并在必要时创建新属性或删除现有属性。
- copyWithin() 方法保留空槽。如果要复制的区域是稀疏的，则原来的空槽会被删除并被替换为拷贝的空槽。
- copyWithin() 方法是通用的。它只期望 this 值具有 length 属性和整数键属性。虽然字符串也是类似数组的，但这种方法不适用于它们，因为字符串是不可变的。

```js
const array1 = ['a', 'b', 'c', 'd', 'e'];
// Copy to index 0 the element at index 3
console.log(array1.copyWithin(0, 3, 4));
// Expected output: Array ["d", "b", "c", "d", "e"]
// Copy to index 1 all elements from index 3 to the end
console.log(array1.copyWithin(1, 3));
// Expected output: Array ["d", "d", "e", "d", "e"]
```

#### 4. `Array.prototype.entries()`: 返回一个新的数组迭代器对象，该对象包含数组中每个索引的键/值对。
- 当在稀疏数组上使用时，entries() 方法迭代空槽，就像它们的值为 undefined 一样。
- entries() 方法是通用的。它只要求 this 值具有 length 属性和以整数为键的属性。

```js
const array1 = ['a', 'b', 'c'];
const iterator1 = array1.entries();
console.log(iterator1.next().value);
// Expected output: Array [0, "a"]
console.log(iterator1.next().value);
// Expected output: Array [1, "b"]
const a = ["a", "b", "c"];
for (const [index, element] of a.entries()) {
    console.log(index, element);
}
// 0 'a'
// 1 'b'
// 2 'c'
for (const element of [, "a"].entries()) {
    console.log(element);
}
// [0, undefined]
// [1, 'a']
```

#### 5. `Array.prototype.every(callbackFn, thisArg)`: 测试一个数组内的所有元素是否都能通过指定函数的测试。它返回一个布尔值。
- 对于空数组，它只返回 true。（这种情况属于无条件正确，因为空集的所有元素都符合给定的条件。）
- callbackFn 仅针对已分配值的数组索引调用。它不会为稀疏数组中的空槽调用。
- every() 不会改变调用它的数组，但指定的 callbackFn 函数可以。但是请注意，数组的长度是在第一次调用 callbackFn 之前保存的。
  - 当开始调用 every() 时，callbackFn 将不会访问超出数组初始长度的任何元素。
  - 对已访问索引的更改不会导致再次在这些元素上调用 callbackFn。
  - 如果数组中一个现有的、尚未访问的元素被 callbackFn 更改，则它传递给 callbackFn 的值将是该元素被修改后的值。被删除的元素则不会被访问。

```js
const isBelowThreshold = (currentValue) => currentValue < 40;
const array1 = [1, 30, 39, 29, 10, 13];
console.log(array1.every(isBelowThreshold));
// Expected output: true
```

#### 6. `Array.prototype.fill()`: 用静态值填充数组中从开始索引到结束索引的所有元素。
#### 7. `Array.prototype.filter()`: 返回一个新数组，其中包含调用所提供的筛选函数返回为 true 的所有数组元素。
#### 8. `Array.prototype.find()`: 返回数组中满足提供的测试函数的第一个元素的值，如果没有找到合适的元素，则返回 undefined。
#### 9.  `Array.prototype.findIndex()`: 返回数组中满足提供的测试函数的第一个元素的索引，如果没有找到合适的元素，则返回 -1。
#### 10. `Array.prototype.findLast()`: 返回数组中满足提供的测试函数的最后一个元素的值，如果没有找到合适的元素，则返回 undefined。
#### 11. `Array.prototype.findLastIndex()`: 返回数组中满足所提供测试函数的最后一个元素的索引，如果没有找到合适的元素，则返回 -1。
#### 12. `Array.prototype.flat()`: 返回一个新数组，所有子数组元素递归地连接到其中，直到指定的深度。
#### 13. `Array.prototype.flatMap()`: 对调用数组的每个元素调用给定的回调函数，然后将结果展平一层，返回一个新数组。
#### 14. `Array.prototype.forEach()`: 对调用数组中的每个元素调用给定的函数。
#### 15. `Array.prototype.includes()`: 确定调用数组是否包含一个值，根据情况返回 true 或 false。
#### 16. `Array.prototype.indexOf()`: 返回在调用数组中可以找到给定元素的第一个（最小）索引。
#### 17. `Array.prototype.join()`: 将数组的所有元素连接为字符串。
#### 18. `Array.prototype.keys()`: 返回一个新的数组迭代器，其中包含调用数组中每个索引的键。
#### 19. `Array.prototype.lastIndexOf()`: 返回在调用数组中可以找到给定元素的最后一个（最大）索引，如果找不到则返回 -1。
#### 20. `Array.prototype.map()`: 返回一个新数组，其中包含对调用数组中的每个元素调用函数的结果。
#### 21. `Array.prototype.pop()`: 从数组中移除最后一个元素并返回该元素。
#### 22. `Array.prototype.push()`: 在数组末尾添加一个或多个元素，并返回数组新的 length。
#### 23. `Array.prototype.reduce()`: 对数组的每个元素（从左到右）执行用户提供的“reducer”回调函数，将其简化为单个值。
#### 24. `Array.prototype.reduceRight()`: 对数组的每个元素（从右到左）执行用户提供的“reducer”回调函数，将其简化为单个值。
#### 25. `Array.prototype.reverse()`: 就地反转数组中元素的顺序。（前面变成后面，后面变成前面。）
#### 26. `Array.prototype.shift()`: 从数组中移除第一个元素并返回该元素。
#### 27. `Array.prototype.slice()`: 提取调用数组的一部分并返回一个新数组。
#### 28. `Array.prototype.some()`: 如果调用数组中至少有一个元素满足提供的测试函数，则返回 true。
#### 29. `Array.prototype.sort()`: 对数组的元素进行排序并返回该数组。
#### 30. `Array.prototype.splice()`: 从数组中添加和/或删除元素。
#### 31. `Array.prototype.toLocaleString()`: 返回一个表示调用数组及其元素的本地化字符串。重写 Object.prototype.toLocaleString() 方法。
#### 32. `Array.prototype.toReversed()`: 返回一个新数组，该数组的元素顺序被反转，但不改变原始数组。
#### 33. `Array.prototype.toSorted()`: 返回一个新数组，其中元素按升序排序，而不改变原始数组。
#### 34. `Array.prototype.toSpliced()`: 返回一个新数组，在给定索引处删除和/或替换了一些元素，而不改变原始数组。
#### 35. `Array.prototype.toString()`: 返回一个表示调用数组及其元素的字符串。重写 Object.prototype.toString() 方法。
#### 36. `Array.prototype.unshift()`: 在数组的前面添加一个或多个元素，并返回数组新的 length。
#### 37. `Array.prototype.values()`: 返回一个新的数组迭代器对象，该对象包含数组中每个索引的值。
#### 38. `Array.prototype.with()`: 返回一个新数组，其中给定索引处的元素替换为给定值，而不改变原始数组。
#### 39. `Array.prototype[@@iterator]()`: Array 实例的 `[@@iterator]()` 方法实现了迭代协议，允许数组被大多数期望可迭代对象的语法所使用，例如展开语法和 `for...of` 循环。它返回一个数组迭代器对象，该对象会产生数组中每个索引的值。该属性的初始值与 Array.prototype.values 属性的初始值是相同的函数对象。
    - 示例：
    ```js
    const arr = ["a", "b", "c"];
    const letterResult = document.getElementById("letterResult");
    for (const letter of arr) {
        const li = document.createElement("li");
        li.textContent = letter;
        letterResult.appendChild(li);
    }
    // a
    // b
    // c
    // 手动执行
    const arr = ["a", "b", "c", "d", "e"];
    const arrIter = arr[Symbol.iterator]();
    console.log(arrIter.next().value); // a
    console.log(arrIter.next().value); // b
    console.log(arrIter.next().value); // c
    console.log(arrIter.next().value); // d
    console.log(arrIter.next().value); // e
    ```
    - 因为字符串和数组都实现了可迭代协议，所以可以设计一个通用函数以相同的方式处理这两种输入。这比直接调用 Array.prototype.values() 更好，后者要求输入是一个数组，或者至少是一个具有这种方法的对象。
    ```js
    function logIterable(it) {
        if (typeof it[Symbol.iterator] !== "function") {
            console.log(it, "不可迭代。");
            return;
        }
        for (const letter of it) {
            console.log(letter);
        }
    }
    // 数组
    logIterable(["a", "b", "c"]);
    // a
    // b
    // c
    // 字符串
    logIterable("abc");
    // a
    // b
    // c
    // 数值
    logIterable(123);
    // 123 不可迭代。
    ```

