## 构造函数

#### `Array()`: 创建一个新的 Array 对象。

!> 调用 `Array()` 时可以使用或不使用 new。两者都会创建一个新的 Array 实例。

- Array 构造函数会根据给定的元素创建一个 JavaScript 数组，但是当仅有一个参数且为数字时除外。注意，后者仅适用于用 Array 构造函数创建数组，而不适用于用方括号创建的数组字面量。

- 如果传递给 Array 构造函数的唯一参数是介于 0 到 232 - 1（含）之间的整数，这将返回一个新的 JavaScript 数组，其 length 属性设置为该数字（注意：这意味着一个由 arrayLength 个空槽组成的数组，而不是具有实际 undefined 值的槽——参见稀疏数组）。

```js
new Array()
new Array(1) // [empty] 创建一个长度为 1 的空数组
new Array('1') // ['1'] 创建一个长度为 1 的数组，且第一个元素为 '1'
new Array(1, 2) // [1, 2] 创建一个长度为 2 的数组，且第一个元素为 1，第二个元素为 2
new Array(1, 2, /* … ,*/ 999)
new Array(arrayLength) // 至输入一个数字会创建该数字长度的空数组，输入其他内容会以该内容创建数组

Array()
Array(1)
Array(1, 2)
Array(1, 2, /* … ,*/ 999)
Array(arrayLength)
```

## 静态方法

#### 1. `Array.from(arrayLike, mapFn, thisArg)`: 从可迭代或类数组对象创建一个新的浅拷贝的数组实例。
- arrayLike 想要转换成数组的类数组或可迭代对象。
- mapFn 可选 调用数组每个元素的函数。如果提供，每个将要添加到数组中的值首先会传递给该函数，然后将 mapFn 的返回值增加到数组中。使用以下参数调用该函数：
  - element 数组当前正在处理的元素。
  - index 数组当前正在处理的元素的索引。
- thisArg 可选 执行 mapFn 时用作 this 的值。
- 返回值 一个新的数组实例。
- Array.from() 可以通过以下方式来创建数组对象：
  - 可迭代对象（例如 Map 和 Set 对象）；或者，如果对象是不可迭代的，
  - 类数组对象（带有 length 属性和索引元素的对象）。
- Array.from() 绝不会创建稀疏数组。如果 arrayLike 对象缺少一些索引属性，那么这些属性在新数组中将是 undefined。
- Array.from() 有一个可选的参数 mapFn，该参数允许你在创建数组时为每个元素执行一个函数，类似于 map()。更明确地说，Array.from(obj, mapFn, thisArg) 和 Array.from(obj).map(mapFn, thisArg) 具有相同的结果，只是它不会创建中间数组，并且 mapFn 仅接受两个参数（element、index），不接受数组，因为数组仍然在构建中。
- Array.from() 方法是一个通用的工厂方法。例如，如果一个数组类的子类继承 from() 方法，继承的 from() 方法将返回新的子类的实例，而不是数组的实例。事实上，this 值可以是任意的构造函数，只要该构造函数接受一个表示新数组长度的单个参数。当一个迭代器对象作为类数组传递时，不带参数调用构造函数；当传递类数组对象时，将携带类数组对象的规范化长度调用构造函数。迭代完成时，将再次设置最终的 length。如果 this 值并不是构造函数，则使用 Array 构造函数。
```js
Array.from("foo");
// [ "f", "o", "o" ]
const set = new Set(["foo", "bar", "baz", "foo"]);
Array.from(set);
// [ "foo", "bar", "baz" ]
const map = new Map([
  [1, 2],
  [2, 4],
  [4, 8],
]);
Array.from(map);
// [[1, 2], [2, 4], [4, 8]]
const mapper = new Map([
  ["1", "a"],
  ["2", "b"],
]);
Array.from(mapper.values());
// ['a', 'b'];
Array.from(mapper.keys());
// ['1', '2'];
function f() {
  return Array.from(arguments);
}
f(1, 2, 3);
// [ 1, 2, 3 ]
// 使用箭头函数作为映射函数去操作多个元素
Array.from([1, 2, 3], (x) => x + x);
// [2, 4, 6]
// 生成一个数字序列。因为数组在每个位置都使用 `undefined` 初始化，下面的 `v` 值将是 `undefined`
Array.from({ length: 5 }, (v, i) => i);
// [0, 1, 2, 3, 4]
// 序列生成器函数（通常称为“range”，例如 Clojure、PHP 等）
const range = (start, stop, step) =>
  Array.from({ length: (stop - start) / step + 1 }, (_, i) => start + i * step);
// 生成的数字范围 0..4
range(0, 4, 1);
// [0, 1, 2, 3, 4]
// 生成的数字范围 1..10，步长为 2
range(1, 10, 2);
// [1, 3, 5, 7, 9]
// 使用 Array.from 生成字母表，并将其序列排序
range("A".charCodeAt(0), "Z".charCodeAt(0), 1).map((x) =>
  String.fromCharCode(x),
);
// ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"]
```
   
#### 2. `Array.fromAsync(arrayLike, mapFn, thisArg)`: 可以由一个异步可迭代对象、可迭代对象或类数组对象创建一个新的、浅拷贝的 Array 实例。
- arrayLike 要转换为数组的异步可迭代、可迭代或类数组对象。
- mapFn 可选 为数组中的每个元素执行的函数。如果提供了该函数，则每个要添加到数组中的值都会先通过该函数处理，mapFn 的返回值将代替该值被添加到数组中（在等待兑现后）。该函数被调用时将传入以下参数：
  - element 数组中当前正在处理的元素。由于所有元素都会先等待其兑现，因此该值永远不会是 thenable。
  - index 正在处理的元素在数组中的索引。
- thisArg 可选 执行 mapFn 时用作 this 的值。
- 返回值 一个新的 Promise，其兑现值是一个新的 Array 实例。
- Array.fromAsync() 允许你从以下对象中创建数组：
  - 异步可迭代对象（如 ReadableStream 和 AsyncGenerator）；或者，如果对象不是异步可迭代的，
  - 可迭代对象（如 Map 和 Set）；或者，如果对象是不可迭代的，
  - 类数组的对象（带有 length 属性和索引元素的对象）。
- Array.fromAsync() 迭代异步可迭代对象的方式与 for await...of 很相似。Array.fromAsync() 在行为上与 Array.from() 几乎等价，除了以下几点：
  - Array.fromAsync() 可以处理异步可迭代对象。
  - Array.fromAsync() 返回一个会兑现为数组实例的 Promise。
  - 如果使用非异步可迭代对象调用 Array.fromAsync()，则要添加到数组中的每个元素（无论是否为 Promise）都会先等待其兑现。
  - 如果提供了 mapFn，则其输入和输出会在内部等待兑现。
- Array.fromAsync() 和 Promise.all() 都可以将一个 promise 可迭代对象转换为一个数组的 promise。然而，它们有两个关键区别：
  - Array.fromAsync() 会依次等待对象中产生的每个值兑现。Promise.all() 会并行等待所有值兑现。
  - Array.fromAsync() 惰性迭代可迭代对象，并且不会获取下一个值，直到当前值被兑现。Promise.all() 预先获取所有值并等待它们全部兑现。
```js
const asyncIterable = (async function* () {
  for (let i = 0; i < 5; i++) {
    await new Promise((resolve) => setTimeout(resolve, 10 * i));
    yield i;
  }
})();
Array.fromAsync(asyncIterable).then((array) => console.log(array));
// [0, 1, 2, 3, 4]
```
```js
Array.fromAsync(
  new Map([
    [1, 2],
    [3, 4],
  ]),
).then((array) => console.log(array));
// [[1, 2], [3, 4]]
Array.fromAsync(
  new Set([Promise.resolve(1), Promise.resolve(2), Promise.resolve(3)]),
).then((array) => console.log(array));
// [1, 2, 3]
Array.fromAsync({
  length: 3,
  0: Promise.resolve(1),
  1: Promise.resolve(2),
  2: Promise.resolve(3),
}).then((array) => console.log(array));
// [1, 2, 3]
function delayedValue(v) {
  return new Promise((resolve) => setTimeout(() => resolve(v), 100));
}
Array.fromAsync(
  [delayedValue(1), delayedValue(2), delayedValue(3)],
  (element) => delayedValue(element * 2),
).then((array) => console.log(array));
// [2, 4, 6]
```
   
#### 3. `Array.isArray(value)`: 用于确定传递的值是否是一个数组，如果参数是数组则返回 true ，否则返回 false。
- value 需要检测的值。
- 返回值 如果 value 是 Array，则为 true；否则为 false。如果 value 是 TypedArray 实例，则总是返回 false。
  - TypedArray 一个 TypedArray 对象描述了底层二进制数据缓冲区的类数组视图。没有称为 TypedArray 的全局属性，也没有直接可用的 TypedArray 构造函数。但是，有很多不同的全局属性，其值是指定元素类型的类型化数组构造函数。
- Array.isArray() 检查传递的值是否为 Array。它不检查值的原型链，也不依赖于它所附加的 Array 构造函数。对于使用数组字面量语法或 Array 构造函数创建的任何值，它都会返回 true。这使得它可以安全地使用跨领域（cross-realm）对象，其中 Array 构造函数的标识是不同的，因此会导致 instanceof Array 失败。
- Array.isArray() 也拒绝原型链中带有 Array.prototype，而实际不是数组的对象，但 instanceof Array 会接受。
- 当检测 Array 实例时，Array.isArray 优于 instanceof，因为 Array.isArray 能跨领域工作。
```js
// 下面的函数调用都返回 true
Array.isArray([]);
Array.isArray([1]);
Array.isArray(new Array());
Array.isArray(new Array("a", "b", "c", "d"));
Array.isArray(new Array(3));
// 鲜为人知的事实：其实 Array.prototype 也是一个数组：
Array.isArray(Array.prototype);
//
// 下面的函数调用都返回 false
Array.isArray();
Array.isArray({});
Array.isArray(null);
Array.isArray(undefined);
Array.isArray(17);
Array.isArray("Array");
Array.isArray(true);
Array.isArray(false);
Array.isArray(new Uint8Array(32));
// 这不是一个数组，因为它不是使用数组字面量语法或 Array 构造函数创建的
Array.isArray({ __proto__: Array.prototype });
```
```js
// instanceof 和 Array.isArray()
// 当检测 Array 实例时，Array.isArray 优于 instanceof，因为 Array.isArray 能跨领域工作。
const iframe = document.createElement("iframe");
document.body.appendChild(iframe);
const xArray = window.frames[window.frames.length - 1].Array;
const arr = new xArray(1, 2, 3); // [1, 2, 3]
// 正确检查 Array
Array.isArray(arr); // true
// arr 的原型是 xArray.prototype，它是一个不同于 Array.prototype 的对象
arr instanceof Array; // false
```

#### 4. `Array.of(element0, element1, /* … ,*/ elementN)`: 通过可变数量的参数创建一个新的 Array 实例，而不考虑参数的数量或类型。
- elementN 用于创建数组的元素。
- 返回值 新的 Array 实例。
- Array.of() 和 Array() 构造函数之间的区别在于对单个参数的处理：Array.of(7) 创建一个具有单个元素 7 的数组，而 Array(7) 创建一个 length 为 7 的空数组（这意味着一个由 7 个空槽组成的数组，而不是由 7 个 undefined 组成的数组）。
- Array.of() 方法是一个通用的工厂方法。例如，如果 Array 的子类继承了 of() 方法，继承的 of() 方法将返回子类的新实例而不是 Array 实例。事实上，this 值可以是任何接受单个参数表示新数组长度的构造函数，并且构造函数将与传递给 of() 的参数数量一起被调用。当所有元素都被分配时，最终的 length 将再次设置。如果 this 值不是构造函数，则改用普通的 Array 构造函数。
```js
Array.of(7); // [7]
Array(7); // 由 7 个空槽组成的数组
Array.of(1, 2, 3); // [1, 2, 3]
Array(1, 2, 3); // [1, 2, 3]
Array.of(undefined); // [undefined]
```
```js
function NotArray(len) {
  console.log("NotArray called with length", len);
}
console.log(Array.of.call(NotArray, 1, 2, 3));
// NotArray called with length 3
// NotArray { '0': 1, '1': 2, '2': 3, length: 3 }
console.log(Array.of.call(Object)); // [Number: 0] { length: 0 }
```
```js
console.log(Array.of.call({}, 1)); // [ 1 ]
```


## 实例属性

- 以下属性在 Array.prototype 上定义，并由所有 Array 实例共享。
   
   1. `Array.prototype.constructor`: 创建实例对象的构造函数。对于 Array 实例，初始值是 Array 构造函数。
   
   2. `Array.prototype[@@unscopables]`: Array.prototype 的 @@unscopables 数据属性被所有 Array 实例共享。它包含在 ES2015 版本之前 ECMAScript 标准中未收纳的属性名，并且这些属性被排除在由 with 语句绑定的环境中。
   
- 以下属性是每个 Array 实例自有的属性。
   
   1. `Array.prototype.length`: length 是 Array 的实例属性，表示该数组中元素的个数。该值是一个无符号 32 位整数，并且其数值总是大于数组最大索引。


## 实例方法

#### 1. `Array.prototype.at(index)`: 接收一个整数值并返回该索引对应的元素，允许正数和负数。负整数从数组中的最后一个元素开始倒数。如果 `index < -array.length` 或 `index >= array.length`，则总是返回 `undefined`，而不会尝试访问相应的属性。
- index 要返回的数组元素的索引（从零开始），会被转换为整数。负数索引从数组末尾开始计数——如果 index < 0，则会访问 index + array.length 位置的元素。
- 返回数组中与给定索引匹配的元素。如果 index < -array.length 或 index >= array.length，则总是返回 undefined，而不会尝试访问相应的属性。
- 在传递非负数时，at() 方法等价于括号表示法。例如，array[0] 和 array.at(0) 均返回第一个元素。但是，当你需要从数组的末端开始倒数时，则不能使用 Python 和 R 语言中支持的 array[-1]，因为方括号内的所有值都会被视为字符串属性，因此你最终读取的是 array["-1"]，这只是一个普通的字符串属性而不是数组索引。
- 通常的做法是访问 length 并将其减去从末端开始的相对索引。例如，array[array.length - 1]。at() 方法允许使用相对索引，因此上面的示例可以简化为 array.at(-1)。
- at() 方法是通用的。其仅期望 this 具有 length 属性和以整数为键的属性。

```js
const array1 = [5, 12, 8, 130, 44];
let index = 2;
console.log(`An index of ${index} returns ${array1.at(index)}`);
// Expected output: "An index of 2 returns 8"
index = -2;
console.log(`An index of ${index} returns ${array1.at(index)}`);
// Expected output: "An index of -2 returns 130"
```

#### 2. `Array.prototype.concat(value0, value1, /* … ,*/ valueN)`: 用于合并两个或多个数组。此方法**不会更改现有数组**，而是返回一个新数组。
- valueN 可选 数组和/或值，将被合并到一个新的数组中。如果省略了所有 valueN 参数，则 concat 会返回调用此方法的现存数组的一个浅拷贝。
- 返回值 新的 Array 实例。
- concat 方法创建一个新数组。该数组将首先由调用它的对象中的元素填充。然后，对于每个参数，它的值将被连接到数组中——对于普通对象或基元，参数本身将成为最终数组的一个元素；对于属性Symbol.isConcatSpreadable设置为真的数组或类数组对象，参数的每个元素都将是独立地添加到最终数组中。concat 方法不会递归到嵌套数组参数中。
- 如果任何源数组是稀疏数组，concat() 方法会保留空槽。
- concat() 方法是一种复制方法。它不会更改 this 或作为参数提供的任何数组，而是返回包含与原始数组中的元素相同的元素的浅拷贝。
- 如果任何源数组是稀疏数组，concat() 方法会保留空槽。
- concat() 方法是通用的。this 值的处理方式与其他参数相同（除了它会先转换为对象），这意味着普通对象将直接添加到结果数组中，而 @@isConcatSpreadable 属性为真值的类数组对象将展开并添加到数组中。

```js
const array1 = ['a', 'b', 'c'];
const array2 = ['d', 'e', 'f'];
const array3 = array1.concat(array2);
console.log(array3);
// Expected output: Array ["a", "b", "c", "d", "e", "f"]
```

#### 3. `Array.prototype.copyWithin(target, start, end)`: 浅复制数组的一部分到同一数组中的另一个位置并替换另一位置的元素值，并返回它，不会改变原数组的长度，但**会改变原数组**。
- target 序列开始替换的目标位置，以 0 为起始的下标表示，且将被转换为整数
  - 负索引将从数组末尾开始计数——如果 target < 0，则实际是 target + array.length。
  - 如果 target < -array.length，则使用 0。
  - 如果 target >= array.length，则不会拷贝任何内容。
  - 如果 target 位于 start 之后，则复制只会持续到 array.length 结束（换句话说，copyWithin() 永远不会扩展数组）。
- start 可选 要复制的元素序列的起始位置，以 0 为起始的下标表示，且将被转换为整数
  - 负索引将从数组末尾开始计数——如果 start < 0，则实际是 start + array.length。
  - 如果省略 start 或 start < -array.length，则默认为 0。
  - 如果 start >= array.length，则不会拷贝任何内容。
- end 可选 要复制的元素序列的结束位置，以 0 为起始的下标表示，且将被转换为整数。copyWithin 将会拷贝到该位置，但不包括 end 这个位置的元素。
  - 负索引将从数组末尾开始计数——如果 end < 0，则实际是 end + array.length。
  - 如果 end < -array.length，则使用0。
  - 如果省略 end 或 end >= array.length，则默认为 array.length，这将导致直到数组末尾的所有元素都被复制。
  - 如果 end 位于 start 之前，则不会拷贝任何内容。
- 返回值 改变后的数组。
- copyWithin() 方法的工作原理类似于 C 和 C++ 的 memmove，是一种移动数组数据的高性能方法，与 TypedArray 的同名方法类似。序列在一次中操作被复制和粘贴；即使复制和粘贴区域重叠，粘贴的序列也将具有复制值。
- copyWithin() 是修改方法。它不会改变 this 指向的对象（数组或类数组）的长度，但会更改其的内容，并在必要时创建新属性或删除现有属性。
- copyWithin() 方法保留空槽。如果要复制的区域是稀疏的，则原来的空槽会被删除并被替换为拷贝的空槽。
- copyWithin() 方法是通用的。它只期望 this 值具有 length 属性和整数键属性。虽然字符串也是类似数组的，但这种方法不适用于它们，因为字符串是不可变的。

```js
console.log([1, 2, 3, 4, 5].copyWithin(-2));
// [1, 2, 3, 1, 2]
console.log([1, 2, 3, 4, 5].copyWithin(0, 3));
// [4, 5, 3, 4, 5]
console.log([1, 2, 3, 4, 5].copyWithin(0, 3, 4));
// [4, 2, 3, 4, 5]
console.log([1, 2, 3, 4, 5].copyWithin(-2, -3, -1));
// [1, 2, 3, 3, 4]
console.log([1, , 3].copyWithin(2, 1, 2)); // [1, empty, empty]
```

#### 4. `Array.prototype.entries()`: 返回一个新的数组迭代器对象，该对象包含数组中每个索引的键/值对。
- 返回值 一个新的可迭代迭代器对象 (en-US)。
- 当在稀疏数组上使用时，entries() 方法迭代空槽，就像它们的值为 undefined 一样。
- entries() 方法是通用的。它只要求 this 值具有 length 属性和以整数为键的属性。

```js
const array1 = ['a', 'b', 'c'];
const iterator1 = array1.entries();
console.log(iterator1.next().value);
// Expected output: Array [0, "a"]
console.log(iterator1.next().value);
// Expected output: Array [1, "b"]
const a = ["a", "b", "c"];
for (const [index, element] of a.entries()) {
    console.log(index, element);
}
// 0 'a'
// 1 'b'
// 2 'c'
for (const element of [, "a"].entries()) {
    console.log(element);
}
// [0, undefined]
// [1, 'a']
```

#### 5. `Array.prototype.every(callbackFn, thisArg)`: 测试一个数组内的所有元素是否都能通过指定函数的测试。它返回一个布尔值。
- callbackFn 为数组中的每个元素执行的函数。它应该返回一个真值以指示元素通过测试，否则返回一个假值。该函数被调用时将传入以下参数：
  - element 数组中当前正在处理的元素。
  - index 正在处理的元素在数组中的索引。
  - array 调用了 every() 的数组本身。
- thisArg 可选 执行 callbackFn 时用作 this 的值。
- 返回值 如果 callbackFn 为每个数组元素返回真值，则为 true。否则为 false。
- every() 方法是一个迭代方法。它为数组中的每个元素调用一次指定的 callbackFn 函数，直到 callbackFn 返回一个假值。如果找到这样的元素，every() 方法将会立即返回 false 并停止遍历数组。否则，如果 callbackFn 为每个元素返回一个真值，every() 就会返回 true。
- every 和数学中的全称量词"任意（∀）"类似。特别的，对于空数组，它只返回 true。（这种情况属于无条件正确，因为空集的所有元素都符合给定的条件。）
- callbackFn 仅针对已分配值的数组索引调用。它不会为稀疏数组中的空槽调用。
- every() 不会改变调用它的数组，但指定的 callbackFn 函数可以。但是请注意，数组的长度是在第一次调用 callbackFn 之前保存的。
  - 当开始调用 every() 时，callbackFn 将不会访问超出数组初始长度的任何元素。
  - 对已访问索引的更改不会导致再次在这些元素上调用 callbackFn。
  - 如果数组中一个现有的、尚未访问的元素被 callbackFn 更改，则它传递给 callbackFn 的值将是该元素被修改后的值。被删除的元素则不会被访问。
- every() 方法是通用的。它只期望 this 值具有 length 属性和整数键属性。

```js
const isBelowThreshold = (currentValue) => currentValue < 40;
const array1 = [1, 30, 39, 29, 10, 13];
console.log(array1.every(isBelowThreshold));
// Expected output: true
const isSubset = (array1, array2) =>
  array2.every((element) => array1.includes(element));
console.log(isSubset([1, 2, 3, 4, 5, 6, 7], [5, 7, 6])); // true
console.log(isSubset([1, 2, 3, 4, 5, 6, 7], [5, 8, 7])); // false
console.log([1, , 3].every((x) => x !== undefined)); // true
console.log([2, , 2].every((x) => x === 2)); // true
```
```js
// --------------
//   修 改 元 素
// --------------
let arr = [1, 2, 3, 4];
arr.every((elem, index, arr) => {
  arr[index + 1]--;
  console.log(`[${arr}][${index}] -> ${elem}`);
  return elem < 2;
});
// 循环会迭代 3 次
// 没有修改的情况下只会迭代 2 次
//
// 第 1 次迭代：[1,1,3,4][0] -> 1
// 第 2 次迭代：[1,1,2,4][1] -> 1
// 第 3 次迭代：[1,1,2,3][2] -> 2
//
// --------------
//   添 加 元 素
// --------------
arr = [1, 2, 3];
arr.every((elem, index, arr) => {
  arr.push("new");
  console.log(`[${arr}][${index}] -> ${elem}`);
  return elem < 4;
});
// 循环迭代 3 次，即使在添加新元素之后
//
// 第 1 次迭代：[1, 2, 3, new][0] -> 1
// 第 2 次迭代：[1, 2, 3, new, new][1] -> 2
// 第 3 次迭代：[1, 2, 3, new, new, new][2] -> 3
//
// --------------
//   删 除 元 素
// --------------
arr = [1, 2, 3, 4];
arr.every((elem, index, arr) => {
  arr.pop();
  console.log(`[${arr}][${index}] -> ${elem}`);
  return elem < 4;
});
// 循环仅迭代 2 次
// 因为剩余的元素被 `pop()` 删除
//
// 第 1 次迭代：[1,2,3][0] -> 1
// 第 2 次迭代：[1,2][1] -> 2
```

#### 6. `Array.prototype.fill(value, start, end)`: 用一个固定值填充一个数组中从起始索引（默认为 0）到终止索引（默认为 array.length）内的全部元素。它返回修改后的数组。
- value 用来填充数组元素的值。注意所有数组中的元素都将是这个确定的值：如果 value 是个对象，那么数组的每一项都会引用这个元素。
- start 可选 基于零的索引，从此开始填充，转换为整数。
  - 负数索引从数组的末端开始计算，如果 start < 0，则使用 start + array.length。
  - 如果 start < -array.length 或 start 被省略，则使用 0。
  - 如果 start >= array.length，没有索引被填充。
- end 可选 基于零的索引，在此结束填充，转换为整数。fill() 填充到但不包含 end 索引。
  - 负数索引从数组的末端开始计算，如果 end < 0，则使用 end + array.length。
  - 如果 end < -array.length，则使用 0。
  - 如果 end >= array.length 或 end 被省略，则使用 array.length，导致所有索引都被填充。
  - 如果经标准化后，end 的位置在 start 之前或之上，没有索引被填充。
- 返回值 经 value 填充修改后的数组。
- fill() 是个修改方法，不会改变 this 的长度，但会改变 this 的内容。
- fill() 也会使用 value 填充稀疏数组的空槽。
- fill() 方法是通用的。它只期望 this 值有一个 length 属性。虽然字符串也是类似数组的，但这个方法不适合应用于它们，因为字符串是不可变的。
- 在一个空数组（length = 0）上使用 Array.prototype.fill() 不会对其进行修改，因为数组没有要修改的内容。要在声明一个数组时使用 Array.prototype.fill()，请确保数组的 length 不为零。
```js
console.log([1, 2, 3].fill(4)); // [4, 4, 4]
console.log([1, 2, 3].fill(4, 1)); // [1, 4, 4]
console.log([1, 2, 3].fill(4, 1, 2)); // [1, 4, 3]
console.log([1, 2, 3].fill(4, 1, 1)); // [1, 2, 3]
console.log([1, 2, 3].fill(4, 3, 3)); // [1, 2, 3]
console.log([1, 2, 3].fill(4, -3, -2)); // [4, 2, 3]
console.log([1, 2, 3].fill(4, NaN, NaN)); // [1, 2, 3]
console.log([1, 2, 3].fill(4, 3, 5)); // [1, 2, 3]
console.log(Array(3).fill(4)); // [4, 4, 4]
// 一个简单的对象，被数组的每个空槽所引用
const arr = Array(3).fill({}); // [{}, {}, {}]
arr[0].hi = "hi"; // [{ hi: "hi" }, { hi: "hi" }, { hi: "hi" }]
const tempGirls = Array(5).fill("girl", 0); // 将所有值设定为一个特定的值。无需指定 end 参数。 注意，数组最初为稀疏数组，没有分配索引。fill() 仍然可以填充这个数组。
console.log(tempGirls); // ["girl", "girl", "girl", "girl", "girl"]
const arrayLike = { length: 2 };
console.log(Array.prototype.fill.call(arrayLike, 1));
// { '0': 1, '1': 1, length: 2 }
```

#### 7. `Array.prototype.filter(callbackFn, thisArg)`: 返回一个新数组，其中包含调用所提供的筛选函数返回为 true 的所有数组元素。
- callbackFn  为数组中的每个元素执行的函数。它应该返回一个真值以将元素保留在结果数组中，否则返回一个假值。该函数被调用时将传入以下参数：
  - element 数组中当前正在处理的元素。
  - index 正在处理的元素在数组中的索引。
  - array 调用了 filter() 的数组本身。
- thisArg 可选 执行 callbackFn 时用作 this 的值。参见迭代方法。
- 返回值 返回给定数组的一部分的浅拷贝，其中只包括通过提供的函数实现的测试的元素。如果没有元素通过测试，则返回一个空数组。
- filter() 方法是一个迭代方法。它为数组中的每个元素调用提供的 callbackFn 函数一次，并构造一个由所有返回真值的元素值组成的新数组。未通过 callbackFn 测试的数组元素不会包含在新数组中。
- callbackFn 仅对已分配值的数组索引调用。它不会对稀疏数组中的空槽调用。
- filter() 方法是一个复制方法。它不会改变 this，而是返回一个包含与原始数组相同的元素（其中某些元素已被过滤掉）的浅拷贝。但是，作为 callbackFn 的函数可以更改数组。请注意，在第一次调用 callbackFn 之前，数组的长度已经被保存。因此：
  - 当开始调用 filter() 时，callbackFn 将不会访问超出数组初始长度的任何元素。
  - 对已访问索引的更改不会导致再次在这些元素上调用 callbackFn。
  - 如果数组中一个现有的、尚未访问的元素被 callbackFn 更改，则它传递给 callbackFn 的值将是该元素被修改后的值。被删除的元素则不会被访问。
- filter() 方法是通用的。它只期望 this 值具有 length 属性和整数键属性。
```js
const array = [-3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13];
function isPrime(num) {
  for (let i = 2; num > i; i++) {
    if (num % i === 0) {
      return false;
    }
  }
  return num > 1;
}
console.log(array.filter(isPrime)); // [2, 3, 5, 7, 11, 13]
const fruits = ["apple", "banana", "grapes", "mango", "orange"];
/**
 * 根据搜索条件（查询）筛选数组项
 */
function filterItems(arr, query) {
  return arr.filter((el) => el.toLowerCase().includes(query.toLowerCase()));
}
console.log(filterItems(fruits, "ap")); // ['apple', 'grapes']
console.log(filterItems(fruits, "an")); // ['banana', 'mango', 'orange']
console.log([1, , undefined].filter((x) => x === undefined)); // [undefined]
console.log([1, , undefined].filter((x) => x !== 2)); // [1, undefined]
const arrayLike = {
  length: 3,
  0: "a",
  1: "b",
  2: "c",
};
console.log(Array.prototype.filter.call(arrayLike, (x) => x <= "b"));
// [ 'a', 'b' ]
```
```js
// 修改每个单词
let words = ["spray", "limit", "exuberant", "destruction", "elite", "present"];
//
const modifiedWords = words.filter((word, index, arr) => {
  arr[index + 1] += " extra";
  return word.length < 6;
});
//
console.log(modifiedWords);
// 注意，在长度为 6 以下有三个单词，但是由于它们已经被修改，所以返回一个单词
// ["spray"]
//
// 添加新单词
words = ["spray", "limit", "exuberant", "destruction", "elite", "present"];
const appendedWords = words.filter((word, index, arr) => {
  arr.push("new");
  return word.length < 6;
});
//
console.log(appendedWords);
// 只有三个符合条件，即使 `words` 本身现在有更多字符长度小于 6 的单词
// ["spray" ,"limit" ,"elite"]
//
// 删除单词
words = ["spray", "limit", "exuberant", "destruction", "elite", "present"];
const deleteWords = words.filter((word, index, arr) => {
  arr.pop();
  return word.length < 6;
});
//
console.log(deleteWords);
// 注意我们没有得到 'elite'，因为它在过滤器访问到它之前就已经从 'words' 弹出了
// ["spray" ,"limit"]
```

#### 8. `Array.prototype.find(callbackFn, thisArg)`: 返回数组中满足提供的测试函数的第一个元素的值，如果没有找到合适的元素，则返回 undefined。
- callbackFn 为数组中的每个元素执行的函数。它应该返回一个真值来表示已经找到了匹配的元素。该函数被调用时将传入以下参数：
  - element 数组中当前正在处理的元素。
  - index 正在处理的元素在数组中的索引。
  - array 调用了 find() 的数组本身。
- thisArg 可选 执行 callbackFn 时用作 this 的值。
- 返回值 数组中第一个满足所提供测试函数的元素的值，否则返回 undefined。
- find() 方法是一个迭代方法。它按索引升序顺序为数组中的每个元素调用提供的 callbackFn 函数，直到 callbackFn 返回一个真值。然后 find() 返回该元素并停止迭代数组。如果 callbackFn 从未返回真值，则 find() 返回 undefined。
- callbackFn 被调用来处理数组的每一个索引，而不仅仅是那些有值的索引。在稀疏数组中，未赋值的空槽与 undefined 表现相同。
- find() 不会改变被调用的数组，但是提供给 callbackFn 的函数可能会改变它。但需要注意的是，在第一次调用 callbackFn 之前，数组的长度会被保存。因此：
  - 当调用 find() 时，callbackFn 不会访问超出数组初始长度的任何元素
  - 对已经访问过的索引的更改不会导致再次在这些元素上调用 callbackFn。
  - 如果 callbackFn 改变了数组中已存在但尚未被访问的元素，则传递给 callbackFn 的该元素的值将是该元素在被访问时的值。被删除的元素被视为 undefined。
- find() 方法是通用的。它只期望 this 值具有 length 属性和整数键属性。
```js
const inventory = [
  { name: "apples", quantity: 2 },
  { name: "bananas", quantity: 0 },
  { name: "cherries", quantity: 5 },
];
const result = inventory.find(({ name }) => name === "cherries");
console.log(result); // { name: 'cherries', quantity: 5 }
const arrayLike = {
  length: 3,
  0: 2,
  1: 7.3,
  2: 4,
};
console.log(Array.prototype.find.call(arrayLike, (x) => !Number.isInteger(x)));
// 7.3
const inventory = [
  { name: "apples", quantity: 2 },
  { name: "bananas", quantity: 0 },
  { name: "cherries", quantity: 5 },
];
const result = inventory.find(({ name }) => name === "cherries");
console.log(result); // { name: 'cherries', quantity: 5 }
const arrayLike = {
  length: 3,
  0: 2,
  1: 7.3,
  2: 4,
};
console.log(Array.prototype.find.call(arrayLike, (x) => !Number.isInteger(x)));
// 7.3
```
```js
// 声明一个在索引 2、3 和 4 处没有元素的数组
const array = [0, 1, , , , 5, 6];
//
// 将会打印所有索引，而不仅仅是那些有值的非空槽
array.find((value, index) => {
  console.log(`访问索引 ${index}，值为 ${value}`);
});
// 访问索引 0，值为 0
// 访问索引 1，值为 1
// 访问索引 2，值为 undefined
// 访问索引 3，值为 undefined
// 访问索引 4，值为 undefined
// 访问索引 5，值为 5
// 访问索引 6，值为 6
//
// 打印所有索引，包括已删除的
array.find((value, index) => {
  // 在第一次迭代时删除元素 5
  if (index === 0) {
    console.log(`删除 array[5] 的值 ${array[5]}`);
    delete array[5];
  }
  // 即使删除了，元素 5 仍然被访问
  console.log(`访问索引 ${index}，值为 ${value}`);
});
// 删除值为 5 的 array[5]
// 访问索引 0，值为 0
// 访问索引 1，值为 1
// 访问索引 2，值为 undefined
// 访问索引 3，值为 undefined
// 访问索引 4，值为 undefined
// 访问索引 5，值为 undefined
// 访问索引 6，值为 6\
```

#### 9.  `Array.prototype.findIndex(callbackFn, thisArg)`: 返回数组中满足提供的测试函数的第一个元素的索引，如果没有找到合适的元素，则返回 -1。
- callbackFn 为数组中的每个元素执行的函数。它应该返回一个真值以指示已找到匹配元素，否则返回一个假值。该函数被调用时将传入以下参数：
  - element 数组中当前正在处理的元素。
  - index 正在处理的元素在数组中的索引。
  - array 调用了 findIndex() 的数组本身。
- thisArg 可选 执行 callbackFn 时用作 this 的值。
- 返回值 数组中第一个满足测试条件的元素的索引。否则返回 -1。
- findIndex() 是一种迭代方法。它按照索引升序依次遍历数组中的每个元素，并调用提供的 callbackFn 函数，直到 callbackFn 返回一个真值。然后 findIndex() 返回该元素的索引并停止遍历数组。如果 callbackFn 从未返回一个真值，则 findIndex() 返回 -1。
- callbackFn 被调用来处理数组的每一个索引，而不仅仅是那些有值的索引。在稀疏数组中，未赋值的空槽与 undefined 表现相同。
- findIndex() 不会改变被调用的数组，但是提供给 callbackFn 的函数可能会改变它。但需要注意的是，在第一次调用 callbackFn 之前，数组的长度会被保存。因此：
  - 当调用 findIndex() 时，callbackFn 不会访问超出数组初始长度的任何元素。
  - 对已经访问过的索引的更改不会导致再次在这些元素上调用 callbackFn。
  - 如果 callbackFn 改变了数组中已存在但尚未被访问的元素，则传递给 callbackFn 的该元素的值将是该元素在被访问时的值。被删除的元素被视为 undefined。
- findIndex() 方法是通用的。它只期望 this 值具有 length 属性和整数键属性。
```js
console.log([5, 12, 8, 130, 44].findIndex((element) => element > 13)); // 3
console.log([1, , 3].findIndex((x) => x === undefined)); // 1
const arrayLike = {
  length: 3,
  0: 2,
  1: 7.3,
  2: 4,
};
console.log(
  Array.prototype.findIndex.call(arrayLike, (x) => !Number.isInteger(x)),
); // 1
const arrayLike = {
  length: 3,
  0: 2,
  1: 7.3,
  2: 4,
};
console.log(
  Array.prototype.findIndex.call(arrayLike, (x) => !Number.isInteger(x)),
); // 1
```

#### 10. `Array.prototype.findLast(callbackFn, thisArg)`: 返回数组中满足提供的测试函数的最后一个元素的值，如果没有找到合适的元素，则返回 undefined。
- callbackFn 数组中测试元素的函数。回调应该返回一个真值，表示已找到匹配的元素，否则返回一个假值。函数在被调用时会传递以下参数：
  - element 当前遍历到的元素。
  - index 当前遍历到的元素的索引（位置）。
  - array 调用 findLast() 的数组本身。
- thisArg 可选 执行 callbackFn 时，用作 this 的值。
- 返回值 数组中满足提供的测试函数索引最高的元素；如果没有元素匹配，返回 undefined。
- findLast() 是一个迭代方法。该方法对数组每一个元素按降序（索引从大到小）执行 callbackFn 函数，直到 callbackFn 返回一个真值。然后 findLast() 返回该元素的值并停止遍历数组。如果 callbackFn 没有返回一个真值，则 findLast() 返回 undefined。
- callbackFn 会被数组中的每个元素调用，而不仅仅是那些被赋值的元素。对于稀疏数组来说，空槽行为和 undefined 相同。
- findLast() 方法不会改变调用它的数组，但是提供的 callbackFn 可以。但是请注意，数组的长度是在第一次调用 callbackFn 之前保存的。因此：
  - callbackFn 不会访问在调用 findLast() 开始后才添加到数组中的任何元素。
  - 给已访问过的索引重新赋值将不会被 callbackFn 重新访问。
  - 如果 callbackFn 更改了数组中现有的、尚未访问的元素，则其传递给 callbackFn 的值将是 findLast() 访问该元素索引时的值。已删除的元素会被当做 undefined 来访问。
- findLast() 方法是通用的。它只期望 this 值具有 length 属性和整数键的属性。
```js
const inventory = [
  { name: "apples", quantity: 2 },
  { name: "bananas", quantity: 0 },
  { name: "fish", quantity: 1 },
  { name: "cherries", quantity: 5 },
];
const result = inventory.findLast(({ quantity }) => quantity < 2);
console.log(result);
// { name: "fish", quantity: 1 }
const arrayLike = {
  length: 3,
  0: 2,
  1: 7.3,
  2: 4,
};
console.log(
  Array.prototype.findLast.call(arrayLike, (x) => Number.isInteger(x)),
); // 4
```
```js
// 声明一个在索引 2、3 和 4 处没有元素的数组
const array = [0, 1, , , , 5, 6];
//
// 显示所有的索引（不只包括那些被赋值的）
array.findLast((value, index) => {
  console.log(`访问索引 ${index}，值为 ${value}`);
});
// 访问索引 6，值为 6
// 访问索引 5，值为 5
// 访问索引 4，值为 undefined
// 访问索引 3，值为 undefined
// 访问索引 2，值为 undefined
// 访问索引 1，值为 1
// 访问索引 0，值为 0
//
// 显示所有的索引（包括已被删除的）
array.findLast((value, index) => {
  // 在第一次迭代时删除值为 5 的元素
  if (index === 6) {
    console.log(`删除值为 array[5]，其值为 ${array[5]}`);
    delete array[5];
  }
  // 元素 5 在被删除后，仍会被访问
  console.log(`访问索引 ${index}，值为 ${value}`);
});
// 删除值为 array[5]，其值为 5
// 访问索引 6，值为 6
// 访问索引 5，值为 undefined
// 访问索引 4，值为 undefined
// 访问索引 3，值为 undefined
// 访问索引 2，值为 undefined
// 访问索引 1，值为 1
// 访问索引 0，值为 0
```

#### 11. `Array.prototype.findLastIndex(callbackFn, thisArg)`: 返回数组中满足所提供测试函数的最后一个元素的索引，如果没有找到合适的元素，则返回 -1。
- callbackFn 对数组中的每个元素执行的函数。回调必须返回一个真值，表示已找到匹配的元素，否则返回一个假值。函数在被调用时会传递以下参数：
  - element 当前遍历到的元素。
  - index 当前正在处理的元素的索引。
  - array 调用 findLastIndex() 的数组本身。
- thisArg 可选 执行 callbackFn 时，用作 this 的值。
- 返回值 数组中通过测试的最后一个（索引最大）元素的索引。如果没有找到任何匹配的元素，则返回 -1。
- findLastIndex() 方法是一个迭代方法。它为数组中的每个元素按索引降序调用一次提供的 callbackFn 函数，直到 callbackFn 返回一个真值。然后 findLastIndex() 返回元素的索引并且停止遍历数组。如果 callbackFn 没有返回一个真值，则 findLastIndex() 返回 -1。
- callbackFn 会为数组中的每个元素调用，而不仅仅是那些被赋值的元素，这意味着对于稀疏数组来说，空槽的行为和 undefined 相同。
- findLastIndex() 方法不会改变调用它的数组，但是提供的 callbackFn 可以。但是请注意，数组的长度是在第一次调用 callbackFn 之前保存的。因此：
  - callbackFn 不会访问在调用 findLastIndex() 开始后才添加到数组中的任何元素。
  - 对已访问索引的更改不会导致对它们再次调用 callbackFn 函数。
  - 如果 callbackFn 更改了数组中现有的、尚未访问的元素，它传递给callbackFn 的值将是该元素被访问时的值。已删除元素被当作 undefined 来访问。
- findLastIndex() 方法是通用的。它只期望 this 值具有 length 属性和整型键属性。
```js
function isPrime(element) {
  if (element % 2 === 0 || element < 2) {
    return false;
  }
  for (let factor = 3; factor <= Math.sqrt(element); factor += 2) {
    if (element % factor === 0) {
      return false;
    }
  }
  return true;
}
console.log([4, 6, 8, 12].findLastIndex(isPrime)); // -1，没有找到
console.log([4, 5, 7, 8, 9, 11, 12].findLastIndex(isPrime)); // 5
console.log([1, , 3].findLastIndex((x) => x === undefined)); // 1
const arrayLike = {
  length: 3,
  0: 2,
  1: 7.3,
  2: 4,
};
console.log(
  Array.prototype.findLastIndex.call(arrayLike, (x) => Number.isInteger(x)),
); // 2
```

#### 12. `Array.prototype.flat(depth)`: 创建一个新的数组，并根据指定深度递归地将所有子数组元素拼接到新的数组中。
- depth 可选 指定要提取嵌套数组的结构深度，默认值为 1。
- 返回值 一个新的数组，其中包含拼接后的子数组元素。
- flat() 方法属于复制方法。它不会改变 this 数组，而是返回一个浅拷贝，该浅拷贝包含了原始数组中相同的元素。
- 如果待展开的数组是稀疏的，flat() 方法会忽略其中的空槽。例如，如果 depth 是 1，那么根数组和第一层嵌套数组中的空槽都会被忽略，但在更深的嵌套数组中的空槽则会与这些数组一起保留。
- flat() 方法是通用的。它只需要 this 值具有 length 属性和整数键属性即可。但是，如果要展开元素，则它们必须是数组。
```js
const arr1 = [1, 2, [3, 4]];
arr1.flat();
// [1, 2, 3, 4]
const arr2 = [1, 2, [3, 4, [5, 6]]];
arr2.flat();
// [1, 2, 3, 4, [5, 6]]
const arr3 = [1, 2, [3, 4, [5, 6]]];
arr3.flat(2);
// [1, 2, 3, 4, 5, 6]
const arr4 = [1, 2, [3, 4, [5, 6, [7, 8, [9, 10]]]]];
arr4.flat(Infinity);
// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
const arr5 = [1, 2, , 4, 5];
console.log(arr5.flat()); // [1, 2, 4, 5]
const array = [1, , 3, ["a", , "c"]];
console.log(array.flat()); // [ 1, 3, "a", "c" ]
const array2 = [1, , 3, ["a", , ["d", , "e"]]];
console.log(array2.flat()); // [ 1, 3, "a", ["d", empty, "e"] ]
console.log(array2.flat(2)); // [ 1, 3, "a", "d", "e"]
const arrayLike = {
  length: 3,
  0: [1, 2],
  // 嵌套的类数组对象不会被展平
  1: { length: 2, 0: 3, 1: 4 },
  2: 5,
};
console.log(Array.prototype.flat.call(arrayLike));
// [ 1, 2, { '0': 3, '1': 4, length: 2 }, 5 ]
```

#### 13. `Array.prototype.flatMap(callbackFn, thisArg)`: 对数组中的每个元素应用给定的回调函数，然后将结果展开一级，返回一个新数组。它等价于在调用 map() 方法后再调用深度为 1 的 flat() 方法（arr.map(...args).flat()），但比分别调用这两个方法稍微更高效一些。
- callbackFn 一个在数组的每个元素上执行的函数。它应该返回一个包含新数组元素的数组，或是要添加到新数组中的单个非数组值。该函数将被传入以下参数：
  - element 数组中正在处理的当前元素。
  - index 数组中正在处理的当前元素的索引。
  - array 调用 flatMap() 的当前数组。
- thisArg 可选 在执行 callbackFn 时用作 this 的值。
- 返回值 一个新的数组，其中每个元素都是回调函数的结果，并且被展开一级。
- flatMap() 方法是一个迭代方法。有关回调函数的详细说明，请参见 Array.prototype.map()。flatMap() 方法等同于调用 map(callbackFn, thisArg) 后再调用 flat(1)——对于每个元素，它都会生成一个新元素数组，并将生成的数组连接起来形成一个新数组。
- flatMap() 方法是通用的。它只需要 this 值具有 length 属性和整数键属性即可。但是，如果要展开从回调函数 callbackFn 返回的值，则该值必须是数组。
- callbackFn 不会被源数组中的空槽调用，因为 map() 不会调用，而 flat() 将忽略返回数组中的空槽。
```js
const arr = [1, 2, 3, 4];
arr.flatMap((x) => [x, x * 2]);
// 等价于
const n = arr.length;
const acc = new Array(n * 2);
for (let i = 0; i < n; i++) {
  const x = arr[i];
  acc[i * 2] = x;
  acc[i * 2 + 1] = x * 2;
}
// [1, 2, 2, 4, 3, 6, 4, 8]
// 在这种特定情况下，flatMap 方法的性能比 for 循环要慢——因为需要创建临时数组并进行垃圾回收，同时返回的数组不需要经常调整大小。但是，在注重灵活性和可读性的情况下，flatMap 仍可能是正确的解决方案。
```
```js
const arr1 = [1, 2, 3, 4];
arr1.map((x) => [x * 2]);
// [[2], [4], [6], [8]]
arr1.flatMap((x) => [x * 2]);
// [2, 4, 6, 8]
// 只有一层被展平
arr1.flatMap((x) => [[x * 2]]);
// [[2], [4], [6], [8]]
const arr1 = ["it's Sunny in", "", "California"];
arr1.map((x) => x.split(" "));
// [["it's","Sunny","in"],[""],["California"]]
arr1.flatMap((x) => x.split(" "));
// ["it's","Sunny","in", "", "California"]
// callbackFn 不会被源数组中的空槽调用，因为 map() 不会调用，而 flat() 将忽略返回数组中的空槽。
console.log([1, 2, , 4, 5].flatMap((x) => [x, x * 2])); // [1, 2, 2, 4, 4, 8, 5, 10]
console.log([1, 2, 3, 4].flatMap((x) => [, x * 2])); // [2, 4, 6, 8]
```
```js
// flatMap 方法可以用作在 map 方法中添加和删除元素（修改元素数量）的方法。换句话说，它允许你将一些项处理为另一些项（通过单独处理每个输入项），而不总是一对一的。在这个意义上，它的作用类似于 filter 的相反操作。如果要保留该项，则返回一个包含该项的单元素数组，如果要添加元素，则返回一个包含多个元素的数组，如果要删除该项，则返回一个空数组。
// 假设我们想要删除所有负数，并将奇数拆分成偶数和 1
const a = [5, 4, -3, 20, 17, -33, -4, 18];
//         |\  \  x   |  | \   x   x   |
//        [4,1, 4,   20, 16, 1,       18]
const result = a.flatMap((n) => {
  if (n < 0) {
    return [];
  }
  return n % 2 === 0 ? [n] : [n - 1, 1];
});
console.log(result); // [4, 1, 4, 20, 16, 1, 18]
```
```js
const arrayLike = {
  length: 3,
  0: 1,
  1: 2,
  2: 3,
};
console.log(Array.prototype.flatMap.call(arrayLike, (x) => [x, x * 2]));
// [1, 2, 2, 4, 3, 6]
// 回调函数返回的类数组对象不会被展平
console.log(
  Array.prototype.flatMap.call(arrayLike, (x) => ({
    length: 1,
    0: x,
  })),
);
// [ { '0': 1, length: 1 }, { '0': 2, length: 1 }, { '0': 3, length: 1 } ]
```

#### 14. `Array.prototype.forEach(callbackFn, thisArg)`: 对调用数组中的每个元素调用给定的函数。
- callbackFn 为数组中每个元素执行的函数。并会丢弃它的返回值。该函数被调用时将传入以下参数：
  - element 数组中正在处理的当前元素。
  - index 数组中正在处理的当前元素的索引。
  - array 调用了 forEach() 的数组本身。
- thisArg 可选 执行 callbackFn 时用作 this 的值。
- 返回值 undefined。
- forEach() 方法是一个迭代方法。它按索引升序地为数组中的每个元素调用一次提供的 callbackFn 函数。与 map() 不同，forEach() 总是返回 undefined，而且不能继续链式调用。其典型的用法是在链式调用的末尾执行某些操作。
- callbackFn 仅对已赋值的数组索引调用。对于稀疏数组中的空槽，它不会被调用。
- forEach() 不会改变其调用的数组，但是，作为 callbackFn 的函数可以更改数组。请注意，在第一次调用 callbackFn 之前，数组的长度已经被保存。因此：
  - 当调用 forEach() 时，callbackFn 不会访问超出数组初始长度的任何元素。
  - 已经访问过的索引的更改不会导致 callbackFn 再次调用它们。
  - 如果 callbackFn 更改了数组中已经存在但尚未访问的元素，则传递给 callbackFn 的值将是在访问该元素时的值。已经被删除的元素不会被访问。
- forEach() 方法是通用的。它只期望 this 值具有 length 属性和整数键的属性。
- 除非抛出异常，否则没有办法停止或中断 forEach() 循环。如果有这样的需求，则不应该使用 forEach() 方法。
- 可以通过像 for、for...of 和 for...in 这样的循环语句来实现提前终止。当不需要进一步迭代时，诸如 every()、some()、find() 和 findIndex() 等数组方法也会立即停止迭代。
- forEach() 期望的是一个同步函数，它不会等待 Promise 兑现。在使用 Promise（或异步函数）作为 forEach 回调时，请确保你意识到这一点可能带来的影响。
```js
const ratings = [5, 4, 5];
let sum = 0;
const sumFunction = async (a, b) => a + b;
ratings.forEach(async (rating) => {
  sum = await sumFunction(sum, rating);
});
console.log(sum);
// 期望的输出：14
// 实际的输出：0
const arraySparse = [1, 3, /* empty */, 7];
let numCallbackRuns = 0;
arraySparse.forEach((element) => {
  console.log({ element });
  numCallbackRuns++;
});
console.log({ numCallbackRuns });
// { element: 1 }
// { element: 3 }
// { element: 7 }
// { numCallbackRuns: 3 }
// 缺失值不会被调用回调函数
```
```js
const words = ["one", "two", "three", "four"];
words.forEach((word) => {
  console.log(word);
  if (word === "two") {
    words.shift(); //'one' 将从数组中删除
  }
}); // one // two // four
console.log(words); // ['two', 'three', 'four']
```
```js
const flatten = (arr) => {
  const result = [];
  arr.forEach((item) => {
    if (Array.isArray(item)) {
      result.push(...flatten(item));
    } else {
      result.push(item);
    }
  });
  return result;
};
// 用例
const nested = [1, 2, 3, [4, 5, [6, 7], 8, 9]];
console.log(flatten(nested)); // [1, 2, 3, 4, 5, 6, 7, 8, 9]
```

#### 15. `Array.prototype.includes(searchElement, fromIndex)`: 用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回 false。
- searchElement 需要查找的值。
- fromIndex 可选，开始搜索的索引（从零开始），会转换为整数。
  - 负索引从数组末尾开始计数——如果 fromIndex < 0，那么实际使用的是 fromIndex + array.length。然而在这种情况下，数组仍然从前往后进行搜索。
  - 如果 fromIndex < -array.length 或者省略 fromIndex，则使用 0，这将导致整个数组被搜索。
  - 如果 fromIndex >= array.length，则不会搜索数组并返回 false。
- 返回一个布尔值，如果在数组中（或者在 fromIndex 所指示的数组部分中，如果指定 fromIndex 的话）找到 searchElement 值，则该值为 true。
- includes() 方法使用零值相等算法将 searchElement 与数组中的元素进行比较。0 值都被认为是相等的，不管符号是什么。（即 -0 等于 0），但 false 不被认为与 0 相同。NaN 可以被正确搜索到。
- 当在稀疏数组上使用时，includes() 方法迭代空槽，就像它们的值是 undefined 一样。
- includes() 方法是通用的。它只期望 this 值具有 length 属性和整数键属性。
- 如果 fromIndex 大于等于数组的长度，则将直接返回 false，且不搜索该数组。
```js
[1, 2, 3].includes(2); // true
[1, 2, 3].includes(4); // false
[1, 2, 3].includes(3, 3); // false
[1, 2, 3].includes(3, -1); // true
[1, 2, NaN].includes(NaN); // true
["1", "2", "3"].includes(3); // false
const arr = ["a", "b", "c"];
arr.includes("c", 3); // false
arr.includes("c", 100); // false
// 数组长度为 3
// fromIndex 为 -100
// 计算出的索引为 3 + (-100) = -97
const arr = ["a", "b", "c"];
arr.includes("a", -100); // true
arr.includes("b", -100); // true
arr.includes("c", -100); // true
arr.includes("a", -2); // false
console.log([1, , 3].includes(undefined)); // true
const arrayLike = {
  length: 3,
  0: 2,
  1: 3,
  2: 4,
};
console.log(Array.prototype.includes.call(arrayLike, 2)); // true
console.log(Array.prototype.includes.call(arrayLike, 1)); // false
```

#### 16. `Array.prototype.indexOf(searchElement, fromIndex)`: 返回在调用数组中可以找到给定元素的第一个（最小）索引。
- searchElement 数组中要查找的元素。
- fromIndex 可选 开始搜索的索引（从零开始），会转换为整数。
  - 负索引从数组末尾开始计数——如果 frommindex < 0，使用 frommindex + array.length。注意，在这种情况下，仍然从前到后搜索数组。
  - 如果 fromIndex < -array.length 或者省略了 fromIndex ，将使用 0，而导致整个数组被搜索。
  - 如果 fromIndex >= array.length，数组不会继续搜索并返回 -1。
- 返回值 首个被找到的元素在数组中的索引位置; 若没有找到则返回 -1。
- indexOf() 使用严格相等（与 === 运算符使用的算法相同）将 searchElement 与数组中的元素进行比较。NaN 值永远不会被比较为相等，因此当 searchElement 为 NaN 时 indexOf() 总是返回 -1。
- indexOf() 方法会跳过稀疏数组中的空槽。
- indexOf() 方法是通用的。它只期望 this 值具有 length 属性和整数键属性。
```js
const array = [2, 9, 9, NaN];
array.indexOf(2); // 0
array.indexOf(7); // -1
array.indexOf(9, 2); // 2
array.indexOf(2, -1); // -1
array.indexOf(2, -3); // 0
array.indexOf(NaN); // -1
console.log([1, , 3].indexOf(undefined)); // -1
const arrayLike = {
  length: 3,
  0: 2,
  1: 3,
  2: 4,
};
console.log(Array.prototype.indexOf.call(arrayLike, 2));
// 0
console.log(Array.prototype.indexOf.call(arrayLike, 5));
// -1
```
```js
// 找出指定元素出现的所有位置
const indices = [];
const array = ["a", "b", "a", "c", "a", "d"];
const element = "a";
let idx = array.indexOf(element);
while (idx !== -1) {
  indices.push(idx);
  idx = array.indexOf(element, idx + 1);
}
console.log(indices);
// [0, 2, 4]
```

#### 17. `Array.prototype.join(separator)`: 将一个数组（或一个类数组对象）的所有元素连接成一个字符串并返回这个字符串，用逗号或指定的分隔符字符串分隔。如果数组只有一个元素，那么将返回该元素而不使用分隔符。
- separator 可选 指定一个字符串来分隔数组的每个元素。如果需要，将分隔符转换为字符串。如果省略，数组元素用逗号（,）分隔。如果 separator 是空字符串（""），则所有元素之间都没有任何字符。
- 返回值 一个所有数组元素连接的字符串。如果 arr.length 为 0，则返回空字符串。
- 所有数组元素被转换成字符串并连接到一个字符串中。如果一个元素是 undefined 或 null，它将被转换为空字符串，而不是字符串 "undefined" 或 "null"。
- Array.prototype.toString() 会在内部访问 join 方法，不带参数。覆盖一个数组实例的 join 也将覆盖它的 toString 行为。
- 当在稀疏数组上使用时，join() 方法迭代空槽，就像它们的值为 undefined 一样。
- join() 方法是通用的。它只期望 this 值具有 length 属性和整数键属性。
```js
const a = ["Wind", "Water", "Fire"];
a.join(); // 'Wind,Water,Fire'
a.join(", "); // 'Wind, Water, Fire'
a.join(" + "); // 'Wind + Water + Fire'
a.join(""); // 'WindWaterFire'
// join() 将空槽视为 undefined，并产生额外的分隔符
console.log([1, , 3].join()); // '1,,3'
console.log([1, undefined, 3].join()); // '1,,3'
// join() 方法读取 this 的 length 属性，然后访问每个整数索引
const arrayLike = {
  length: 3,
  0: 2,
  1: 3,
  2: 4,
};
console.log(Array.prototype.join.call(arrayLike));
// 2,3,4
console.log(Array.prototype.join.call(arrayLike, "."));
// 2.3.4
```

#### 18. `Array.prototype.keys()`: 返回一个新的数组迭代器，其中包含调用数组中每个索引的键。
- 返回值 一个新的可迭代迭代器对象 (en-US)。
- 当用于稀疏数组时，keys() 方法迭代空槽，就像它们的值为 undefined 一样。
- keys() 方法是通用的。它只期望 this 值具有 length 属性和整数键属性。
- 与 Object.keys() 只包含数组中实际存在的键不同，keys() 迭代器不会忽略缺失属性的键。
```js
const arr = ["a", , "c"];
const sparseKeys = Object.keys(arr);
const denseKeys = [...arr.keys()];
console.log(sparseKeys); // ['0', '2']
console.log(denseKeys); // [0, 1, 2]
//
const arrayLike = {
  length: 3,
};
for (const entry of Array.prototype.keys.call(arrayLike)) {
  console.log(entry);
}
// 0
// 1
// 2
```

#### 19. `Array.prototype.lastIndexOf(searchElement, fromIndex)`: 返回数组中给定元素最后一次出现的索引，如果不存在则返回 -1。该方法从 fromIndex 开始向前搜索数组。
- searchElement 被查找的元素。
- fromIndex 可选 以 0 起始的索引，表明反向搜索的起始位置，会被转换为整数。
  - 如果 fromIndex < 0，则从数组末尾开始倒数计数——即使用 fromIndex + array.length 的值。
  - 如果 fromIndex < -array.length，则不搜索数组并返回 -1。从概念上讲，你可以把它想象成从数组开始之前不存在的位置开始反向搜索，这条路径上没有任何数组元素，因此 searchElement 永远不会被找到。
  - 如果 fromIndex >= array.length 或者省略了 fromIndex，则使用 array.length - 1，这会导致搜索整个数组。可以将其理解为从数组尾部之后不存在的位置开始向前搜索。最终会访问到数组最后一个元素，并继续向前开始实际搜索数组元素。
- 返回值 数组中该元素最后一次出现的索引，如未找到返回 -1。
- lastIndexOf 使用严格相等（与 === 运算符使用的算法相同）比较 searchElement 和数组中的元素。NaN 值永远不会被比较为相等，因此当 searchElement 为 NaN 时 lastIndexOf() 总是返回 -1。
- lastIndexOf() 方法会跳过稀疏数组中的空槽。
- lastIndexOf() 方法是通用的。它只期望 this 值具有 length 属性和整数键属性。
```js
const numbers = [2, 5, 9, 2];
numbers.lastIndexOf(2); // 3
numbers.lastIndexOf(7); // -1
numbers.lastIndexOf(2, 3); // 3
numbers.lastIndexOf(2, 2); // 0
numbers.lastIndexOf(2, -2); // 0
numbers.lastIndexOf(2, -1); // 3
const array = [NaN];
array.lastIndexOf(NaN); // -1
console.log([1, , 3].lastIndexOf(undefined)); // -1
const arrayLike = {
  length: 3,
  0: 2,
  1: 3,
  2: 2,
};
console.log(Array.prototype.lastIndexOf.call(arrayLike, 2));
// 2
console.log(Array.prototype.lastIndexOf.call(arrayLike, 5));
// -1
```
```js
const indices = [];
const array = ["a", "b", "a", "c", "a", "d"];
const element = "a";
let idx = array.lastIndexOf(element);
while (idx !== -1) {
  indices.push(idx);
  idx = idx > 0 ? array.lastIndexOf(element, idx - 1) : -1;
}
console.log(indices);
// [4, 2, 0]
```

#### 20. `Array.prototype.map(callbackFn, thisArg)`: 创建一个新数组，这个新数组由原数组中的每个元素都调用一次提供的函数后的返回值组成。
- callbackFn 为数组中的每个元素执行的函数。它的返回值作为一个元素被添加为新数组中。该函数被调用时将传入以下参数：
  - element 数组中当前正在处理的元素。
  - index 正在处理的元素在数组中的索引。
  - array 调用了 map() 的数组本身。
- thisArg 可选 执行 callbackFn 时用作 this 的值。
- 返回值 一个新数组，每个元素都是回调函数的返回值。
- map() 方法是一个迭代方法。它为数组中的每个元素调用一次提供的 callbackFn 函数，并用结果构建一个新数组。
- callbackFn 仅在已分配值的数组索引处被调用。它不会在稀疏数组中的空槽处被调用。
- map() 方法是一个复制方法。它不会改变 this。然而，作为 callbackFn 提供的函数可以更改数组。请注意，在第一次调用 callbackFn 之前，数组的长度已经被保存。因此：
  - 当开始调用 map() 时，callbackFn 将不会访问超出数组初始长度的任何元素。
  - 对已访问索引的更改不会导致再次在这些元素上调用 callbackFn。
  - 如果数组中一个现有的、尚未访问的元素被 callbackFn 更改，则它传递给 callbackFn 的值将是该元素被修改后的值。被删除的元素则不会被访问。
- map() 方法是通用的。它只期望 this 值具有 length 属性和整数键属性。
- 由于 map 创建一个新数组，在没有使用返回的数组的情况下调用它是不恰当的；应该使用 forEach 或 for...of 作为代替。
```js
const numbers = [1, 4, 9];
const roots = numbers.map((num) => Math.sqrt(num));
// roots 现在是     [1, 2, 3]
// numbers 依旧是   [1, 4, 9]
const kvArray = [
  { key: 1, value: 10 },
  { key: 2, value: 20 },
  { key: 3, value: 30 },
];
const reformattedArray = kvArray.map(({ key, value }) => ({ [key]: value }));
console.log(reformattedArray); // [{ 1: 10 }, { 2: 20 }, { 3: 30 }]
console.log(kvArray);
// [
//   { key: 1, value: 10 },
//   { key: 2, value: 20 },
//   { key: 3, value: 30 }
// ]
const arrayLike = {
  length: 3,
  0: 2,
  1: 3,
  2: 4,
};
console.log(Array.prototype.map.call(arrayLike, (x) => x ** 2));
// [ 4, 9, 16 ]
console.log(
  [1, , 3].map((x, index) => {
    console.log(`Visit ${index}`);
    return x * 2;
  }),
);
// Visit 0
// Visit 2
// [2, empty, 6]
```
```js
const numbers = [1, 2, 3, 4];
const filteredNumbers = numbers.map((num, index) => {
  if (index < 3) {
    return num;
  }
});
// index 从 0 开始，因此 filterNumbers 为 1、2、3 和 undefined。
// filteredNumbers 是 [1, 2, 3, undefined]
// numbers 依旧是 [1, 2, 3, 4]
```

#### 21. `Array.prototype.pop()`: 从数组中删除最后一个元素，并返回该元素的值。此方法会更改数组的长度。
- 返回值 从数组中删除的元素（当数组为空时返回 undefined）。
- pop() 方法从一个数组中删除并返回最后一个元素给调用者。如果你在空数组上调用 pop()，它会返回 undefined。
- Array.prototype.shift() 和 pop() 有类似的行为，但是它是作用在数组的第一个元素上的。
- pop() 是修改方法。其改变了 this 的长度和内容。如果你想要 this 不变，但是返回一个新的最后一个元素被移除的数组，你可以使用 arr.slice(0, -1) 来代替。
- pop() 方法是通用的。它只期望 this 值具有 length 属性和整数键属性。虽然字符串也是类数组对象，但是由于其不能被修改，所以 pop() 方法并不能应用在字符串上。
```js
const myFish = ["angel", "clown", "mandarin", "sturgeon"];
const popped = myFish.pop();
console.log(myFish); // ['angel', 'clown', 'mandarin' ]
console.log(popped); // 'sturgeon'
//
// pop() 方法会读取 this 上的 length 属性。如果规范化的 length 属性为 0，length 会被再次设置为 0（鉴于之前可能是负数或者 undefined）。否则，返回并删除位于 length - 1 处的属性。
const arrayLike = {
  length: 3,
  unrelated: "foo",
  2: 4,
};
console.log(Array.prototype.pop.call(arrayLike));
// 4
console.log(arrayLike);
// { length: 2, unrelated: 'foo' }
const plainObj = {};
// 没有 length 属性，所以长度为 0
Array.prototype.pop.call(plainObj);
console.log(plainObj);
// { length: 0 }
```
```js
const collection = {
  length: 0,
  addElements(...elements) {
    // 每次添加元素时
    // obj.length 都会自动增加
    // 返回 push 方法的返回值，即 length 属性的新值
    return [].push.call(this, ...elements);
  },
  removeElement() {
    // 每次移除元素时
    // obj.length 都会自动减少
    // 返回 pop 方法的返回值，即被移除的元素
    return [].pop.call(this);
  },
};
collection.addElements(10, 20, 30);
console.log(collection.length); // 3
collection.removeElement();
console.log(collection.length); // 2
```

#### 22. `Array.prototype.push(element0, element1, /* … ,*/ elementN)`: 将指定的元素添加到数组的末尾，并返回新的数组长度。
- elementN 添加到数组末尾的元素。
- 返回值 调用方法的对象的新 length 属性。
- push() 方法将值追加到一个数组中。
- Array.prototype.unshift() 有着和 push() 相似的行为，但是其作用于数组的开头。
- push() 方法是一个修改方法。它改变了 this 的内容和长度。如果你希望 this 的值保持不变，但返回一个末尾追加了元素的新数组，你可以使用 arr.concat([element0, element1, /* ... ,*/ elementN]) 来代替。请注意，这些元素需要被包装在一个额外的数组中——否则，如果元素本身是一个数组，由于 concat() 的行为，它将被展开而不是作为单个元素添加到原数组的末尾。
- push() 方法是通用的。它只期望 this 值具有 length 属性和整数键属性。虽然字符串也是类似数组的，但这个方法不适用于它，因为字符串是不可变的。
```js
const sports = ["soccer", "baseball"];
const total = sports.push("football", "swimming");
console.log(sports); // ['soccer', 'baseball', 'football', 'swimming']
console.log(total); // 4
const vegetables = ["parsnip", "potato"];
const moreVegs = ["celery", "beetroot"];
// 合并第二个数组到第一个数组中
vegetables.push(...moreVegs);
console.log(vegetables); // ['parsnip', 'potato', 'celery', 'beetroot']
const arrayLike = {
  length: 3,
  unrelated: "foo",
  2: 4,
};
Array.prototype.push.call(arrayLike, 1, 2);
console.log(arrayLike);
// { '2': 4, '3': 1, '4': 2, length: 5, unrelated: 'foo' }
const plainObj = {};
// 这里没有长度属性，所以长度为 0
Array.prototype.push.call(plainObj, 1, 2);
console.log(plainObj);
// { '0': 1, '1': 2, length: 2 }
const obj = {
  length: 0,
  addElem(elem) {
    // obj.length 在每次添加元素时自动增加
    [].push.call(this, elem);
  },
};
// 让我们添加一些空对象来说明
obj.addElem({});
obj.addElem({});
console.log(obj.length); // 2
```

#### 23. `Array.prototype.reduce(callbackFn, initialValue)`: 对数组的每个元素（从左到右）执行用户提供的“reducer”回调函数，将其简化为单个值。
- callbackFn 为数组中每个元素执行的函数。其返回值将作为下一次调用 callbackFn 时的 accumulator 参数。对于最后一次调用，返回值将作为 reduce() 的返回值。该函数被调用时将传入以下参数：
  - accumulator 上一次调用 callbackFn 的结果。在第一次调用时，如果指定了 initialValue 则为指定的值，否则为 array[0] 的值。
  - currentValue 当前元素的值。在第一次调用时，如果指定了 initialValue，则为 array[0] 的值，否则为 array[1]。
  - currentIndex currentValue 在数组中的索引位置。在第一次调用时，如果指定了 initialValue 则为 0，否则为 1。
  - array 调用了 reduce() 的数组本身。
- initialValue 可选 第一次调用回调时初始化 accumulator 的值。如果指定了 initialValue，则 callbackFn 从数组中的第一个值作为 currentValue 开始执行。如果没有指定 initialValue，则 accumulator 初始化为数组中的第一个值，并且 callbackFn 从数组中的第二个值作为 currentValue 开始执行。在这种情况下，如果数组为空（没有第一个值可以作为 accumulator 返回），则会抛出错误。
- 返回值 使用“reducer”回调函数遍历整个数组后的结果。
- 异常 TypeError 如果数组为空且未提供 initialValue，则会抛出异常。
- reduce() 方法对数组中的每个元素按序执行一个提供的 reducer 函数，每一次运行 reducer 会将先前元素的计算结果作为参数传入，最后将其结果汇总为单个返回值。
- 第一次执行回调函数时，不存在“上一次的计算结果”。如果需要回调函数从数组索引为 0 的元素开始执行，则需要传递初始值。否则，数组索引为 0 的元素将被用作初始值，迭代器将从第二个元素开始执行（即从索引为 1 而不是 0 的位置开始）。
- reduce() 方法是一个迭代方法。它按升序对数组中的所有元素运行一个“reducer”回调函数，并将它们累积到一个单一的值中。每次调用时，callbackFn 的返回值都作为 accumulator 参数传递到下一次调用中。accumulator 的最终值（也就是在数组的最后一次迭代中从 callbackFn 返回的值）将作为 reduce() 的返回值。
- callbackFn 仅对已分配值的数组索引进行调用。不会对稀疏数组中的空槽进行调用。
- 与其他迭代方法不同，reduce() 不接受 thisArg 参数。callbackFn 调用时始终以 undefined 作为 this 的值，如果 callbackFn 未处于严格模式，则该值将被替换为 globalThis。
- reduce() 是函数式编程中的一个核心概念，在函数式编程中，不可能改变任何值，因此为了累积数组中的所有值，必须在每次迭代中返回一个新的累加器。这种约定也适用于 JavaScript 的 reduce()：应该在可能的情况下使用展开语法或其他复制方法来创建新的数组和对象作为累加器，而不是改变现有的累加器。如果你决定改变累加器而不是复制它，请记得仍然在回调中返回修改后的对象，否则下一次迭代将收到 undefined。
- reduce() 不会改变被调用的数组，但是作为 callbackFn 提供的函数可能会改变数组。但需要注意的是，在第一次调用 callbackFn 之前，数组的长度会被保存。因此：
  - 当开始调用 reduce() 时，callbackFn 将不会访问超出数组初始长度的任何元素。
  - 已访问索引的更改不会导致再次在这些元素上调用 callbackFn。
  - 如果数组中一个现有的、尚未访问的元素被 callbackFn 更改，则它传递给 callbackFn 的值将是该元素被修改后的值。被删除的元素则不会被访问。
- reduce() 方法是通用的。它只期望 this 值具有 length 属性和整数键属性。
- 像 reduce() 这样的递归函数可能非常强大，但有时可能很难理解，特别是对于缺乏经验的 JavaScript 开发人员。如果使用其他数组方法可以使代码更清晰，则开发人员必须权衡代码可读性与使用 reduce() 带来的好处。如果 reduce() 确实是最佳选择，应该通过良好的文档和语义化的变量命名来提高代码的可读性。
- 如果数组只有一个元素（无论位置如何）且未提供 initialValue，或者提供了 initialValue 但数组为空，则将返回该单个值，而不调用 callbackFn。
- 如果提供了 initialValue 且数组不为空，则 reduce 方法将始终从索引 0 开始调用回调函数。
- 如果未提供 initialValue，则对于长度大于 1、等于 1 和 0 的数组，reduce 方法将有不同的表现，如以下示例所示：
```js
const getMax = (a, b) => Math.max(a, b);
// 从索引 0 开始为数组中的每个元素调用回调函数
[1, 100].reduce(getMax, 50); // 100
[50].reduce(getMax, 10); // 50
// 仅为索引 1 处的元素调用回调函数
[1, 100].reduce(getMax); // 100
// 不调用回调函数
[50].reduce(getMax); // 50
[].reduce(getMax, 1); // 1
[].reduce(getMax); // TypeError
```
```js
const array = [15, 16, 17, 18, 19];
function reducer(accumulator, currentValue, index) {
  const returns = accumulator + currentValue;
  console.log(
    `accumulator: ${accumulator}, currentValue: ${currentValue}, index: ${index}, returns: ${returns}`,
  );
  return returns;
}
array.reduce(reducer);
// 回调函数会被调用四次，每次调用的参数和返回值如下：
//              accumulator	currentValue	index	返回值
// 第一次调用	        15	        16	        1	   31
// 第二次调用	        31	        17	        2	   48
// 第三次调用	        48	        18	        3	   66
// 第四次调用	        66	        19	        4	   85
// array 参数在整个过程中始终不会改变——它始终是 [15, 16, 17, 18, 19]。reduce() 返回的值将是最后一次回调返回值（85）。
```
```js
[15, 16, 17, 18, 19].reduce(
  (accumulator, currentValue) => accumulator + currentValue,
  10,
);
// 回调函数会被调用五次，每次调用的参数和返回值如下表：
//            accumulator	currentValue	index	返回值
// 第一次调用	      10	         15 	      0	   25
// 第二次调用	      25	         16 	      1	   41
// 第三次调用	      41	         17 	      2	   58
// 第四次调用	      58	         18 	      3	   76
// 第五次调用	      76	         19 	      4	   95
// 这种情况下 reduce() 返回的值是 95。
```
```js
// 求对象数组中值的总和
const objects = [{ x: 1 }, { x: 2 }, { x: 3 }];
const sum = objects.reduce(
  (accumulator, currentValue) => accumulator + currentValue.x,
  0,
);
console.log(sum); // 6
```
```js
// 展平嵌套数组
const flattened = [
  [0, 1],
  [2, 3],
  [4, 5],
].reduce((accumulator, currentValue) => accumulator.concat(currentValue), []);
// flattened 的值是 [0, 1, 2, 3, 4, 5]
```
```js
// 统计对象中值的出现次数
const names = ["Alice", "Bob", "Tiff", "Bruce", "Alice"];
const countedNames = names.reduce((allNames, name) => {
  const currCount = allNames[name] ?? 0;
  return {
    ...allNames,
    [name]: currCount + 1,
  };
}, {});
// countedNames 的值是：
// { 'Alice': 2, 'Bob': 1, 'Tiff': 1, 'Bruce': 1 }
```
```js
// 按属性对对象进行分组
const people = [
  { name: "Alice", age: 21 },
  { name: "Max", age: 20 },
  { name: "Jane", age: 20 },
];
function groupBy(objectArray, property) {
  return objectArray.reduce((acc, obj) => {
    const key = obj[property];
    const curGroup = acc[key] ?? [];

    return { ...acc, [key]: [...curGroup, obj] };
  }, {});
}
const groupedPeople = groupBy(people, "age");
console.log(groupedPeople);
// {
//   20: [
//     { name: 'Max', age: 20 },
//     { name: 'Jane', age: 20 }
//   ],
//   21: [{ name: 'Alice', age: 21 }]
// }
```
```js
// 使用展开语法和 initialValue 连接包含在对象数组中的数组
// friends——一个对象数组，其中对象字段“books”是最喜欢的书的列表
const friends = [
  {
    name: "Anna",
    books: ["Bible", "Harry Potter"],
    age: 21,
  },
  {
    name: "Bob",
    books: ["War and peace", "Romeo and Juliet"],
    age: 26,
  },
  {
    name: "Alice",
    books: ["The Lord of the Rings", "The Shining"],
    age: 18,
  },
];
// allbooks——列表，其中包含所有朋友的书籍和 initialValue 中包含的附加列表
const allbooks = friends.reduce(
  (accumulator, currentValue) => [...accumulator, ...currentValue.books],
  ["Alphabet"],
);
console.log(allbooks);
// [
//   'Alphabet', 'Bible', 'Harry Potter', 'War and peace',
//   'Romeo and Juliet', 'The Lord of the Rings',
//   'The Shining'
// ]
```
```js
// 数组去重
// 可以使用 Set 和 Array.from() 来实现相同的效果，如 const arrayWithNoDuplicates = Array.from(new Set(myArray))，并且性能更好。
//
const myArray = ["a", "b", "a", "b", "c", "e", "e", "c", "d", "d", "d", "d"];
const myArrayWithNoDuplicates = myArray.reduce((accumulator, currentValue) => {
  if (!accumulator.includes(currentValue)) {
    return [...accumulator, currentValue];
  }
  return accumulator;
}, []);
console.log(myArrayWithNoDuplicates);
```
```js
// 使用 reduce() 来替代 .filter().map()
// 使用 filter() 和 map() 会遍历数组两次，但是你可以使用 reduce() 只遍历一次并实现相同的效果，从而更高效。（如果你喜欢使用 for 循环，你可以在遍历一次时使用 forEach() 进行过滤和映射。）
const numbers = [-5, 6, 2, 0];
const doubledPositiveNumbers = numbers.reduce((accumulator, currentValue) => {
  if (currentValue > 0) {
    const doubled = currentValue * 2;
    return [...accumulator, doubled];
  }
  return accumulator;
}, []);
console.log(doubledPositiveNumbers); // [12, 4]
```
```js
// 按顺序运行 Promise
/**
 * 链接一系列 Promise 处理程序。
 *
 * @param {array} arr——一个 Promise 处理程序列表，每个处理程序接收前一个处理程序解决的结果并返回另一个 Promise。
 * @param {*} input——开始调用 Promise 链的初始值
 * @return {Object}——由一系列 Promise 链接而成的 Promise
 */
function runPromiseInSequence(arr, input) {
  return arr.reduce(
    (promiseChain, currentFunction) => promiseChain.then(currentFunction),
    Promise.resolve(input),
  );
}
// Promise 函数 1
function p1(a) {
  return new Promise((resolve, reject) => {
    resolve(a * 5);
  });
}
// Promise 函数 2
function p2(a) {
  return new Promise((resolve, reject) => {
    resolve(a * 2);
  });
}
// 函数 3——将由 `.then()` 包装在已解决的 Promise 中
function f3(a) {
  return a * 3;
}
// Promise 函数 4
function p4(a) {
  return new Promise((resolve, reject) => {
    resolve(a * 4);
  });
}
const promiseArr = [p1, p2, f3, p4];
runPromiseInSequence(promiseArr, 10).then(console.log); // 1200
```
```js
// 使用函数组合实现管道
// 组合使用的构建块
const double = (x) => 2 * x;
const triple = (x) => 3 * x;
const quadruple = (x) => 4 * x;
// 函数组合，实现管道功能
const pipe =
  (...functions) =>
  (initialValue) =>
    functions.reduce((acc, fn) => fn(acc), initialValue);
// 组合的函数，实现特定值的乘法
const multiply6 = pipe(double, triple);
const multiply9 = pipe(triple, triple);
const multiply16 = pipe(quadruple, quadruple);
const multiply24 = pipe(double, triple, quadruple);
// 用例
multiply6(6); // 36
multiply9(9); // 81
multiply16(16); // 256
multiply24(10); // 240
```
```js
// 在稀疏数组中使用 reduce()
// reduce() 会跳过稀疏数组中缺失的元素，但不会跳过 undefined 值。
console.log([1, 2, , 4].reduce((a, b) => a + b)); // 7
console.log([1, 2, undefined, 4].reduce((a, b) => a + b)); // NaN
```
```js
// 在非数组对象上调用 reduce()
// reduce() 方法读取 this 的 length 属性，然后访问每个整数索引。
const arrayLike = {
  length: 3,
  0: 2,
  1: 3,
  2: 4,
};
console.log(Array.prototype.reduce.call(arrayLike, (x, y) => x + y));
// 9
```

#### 24. `Array.prototype.reduceRight()`: 对数组的每个元素（从右到左）执行用户提供的“reducer”回调函数，将其简化为单个值。
#### 25. `Array.prototype.reverse()`: 就地反转数组中元素的顺序。（前面变成后面，后面变成前面。）
#### 26. `Array.prototype.shift()`: 从数组中移除第一个元素并返回该元素。
#### 27. `Array.prototype.slice()`: 提取调用数组的一部分并返回一个新数组。
#### 28. `Array.prototype.some()`: 如果调用数组中至少有一个元素满足提供的测试函数，则返回 true。
#### 29. `Array.prototype.sort()`: 对数组的元素进行排序并返回该数组。
#### 30. `Array.prototype.splice()`: 从数组中添加和/或删除元素。
#### 31. `Array.prototype.toLocaleString()`: 返回一个表示调用数组及其元素的本地化字符串。重写 Object.prototype.toLocaleString() 方法。
#### 32. `Array.prototype.toReversed()`: 返回一个新数组，该数组的元素顺序被反转，但不改变原始数组。
#### 33. `Array.prototype.toSorted()`: 返回一个新数组，其中元素按升序排序，而不改变原始数组。
#### 34. `Array.prototype.toSpliced()`: 返回一个新数组，在给定索引处删除和/或替换了一些元素，而不改变原始数组。
#### 35. `Array.prototype.toString()`: 返回一个表示调用数组及其元素的字符串。重写 Object.prototype.toString() 方法。
#### 36. `Array.prototype.unshift()`: 在数组的前面添加一个或多个元素，并返回数组新的 length。
#### 37. `Array.prototype.values()`: 返回一个新的数组迭代器对象，该对象包含数组中每个索引的值。
#### 38. `Array.prototype.with()`: 返回一个新数组，其中给定索引处的元素替换为给定值，而不改变原始数组。
#### 39. `Array.prototype[@@iterator]()`: Array 实例的 `[@@iterator]()` 方法实现了迭代协议，允许数组被大多数期望可迭代对象的语法所使用，例如展开语法和 `for...of` 循环。它返回一个数组迭代器对象，该对象会产生数组中每个索引的值。该属性的初始值与 Array.prototype.values 属性的初始值是相同的函数对象。
    - 示例：
    ```js
    const arr = ["a", "b", "c"];
    const letterResult = document.getElementById("letterResult");
    for (const letter of arr) {
        const li = document.createElement("li");
        li.textContent = letter;
        letterResult.appendChild(li);
    }
    // a
    // b
    // c
    // 手动执行
    const arr = ["a", "b", "c", "d", "e"];
    const arrIter = arr[Symbol.iterator]();
    console.log(arrIter.next().value); // a
    console.log(arrIter.next().value); // b
    console.log(arrIter.next().value); // c
    console.log(arrIter.next().value); // d
    console.log(arrIter.next().value); // e
    ```
    - 因为字符串和数组都实现了可迭代协议，所以可以设计一个通用函数以相同的方式处理这两种输入。这比直接调用 Array.prototype.values() 更好，后者要求输入是一个数组，或者至少是一个具有这种方法的对象。
    ```js
    function logIterable(it) {
        if (typeof it[Symbol.iterator] !== "function") {
            console.log(it, "不可迭代。");
            return;
        }
        for (const letter of it) {
            console.log(letter);
        }
    }
    // 数组
    logIterable(["a", "b", "c"]);
    // a
    // b
    // c
    // 字符串
    logIterable("abc");
    // a
    // b
    // c
    // 数值
    logIterable(123);
    // 123 不可迭代。
    ```

